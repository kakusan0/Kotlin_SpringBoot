<!DOCTYPE html>
<html lang="ja" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8"/>
    <title>勤怠管理</title>
    <link href="/webjars/bootstrap/5.3.8/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="/webjars/bootstrap-icons/1.13.1/font/bootstrap-icons.css" rel="stylesheet"/>
    <style>
        .working {
            color: #28a745;
            font-weight: bold;
        }

        /* Ensure report buttons are positioned relative to the table and visible */
        .table-with-controls {
            position: relative;
        }

        #reportButtons {
            position: absolute;
            right: 0;
            top: -2.2rem;
            z-index: 999;
        }

        @media (max-width: 767px) {
            #reportButtons {
                position: static;
                top: auto;
                right: auto;
                margin-bottom: .5rem;
            }
        }
    </style>
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
</head>
<body class="container py-4">
<h1>勤怠管理 (リアルタイム)</h1>
<div class="mb-3">
    <button class="btn btn-success btn-lg" id="registerBtn">
        <i class="bi bi-calendar-check"></i> 勤怠登録
    </button>
</div>
<div class="mb-3" id="status"></div>
<div class="card mb-3">
    <div class="card-body">
        <h5 class="card-title">打刻操作</h5>
        <div class="d-flex gap-2">
            <button class="btn btn-primary" id="clockInBtn">
                <i class="bi bi-box-arrow-in-right"></i> 出勤
            </button>
            <button class="btn btn-danger" id="clockOutBtn">
                <i class="bi bi-box-arrow-left"></i> 退勤
            </button>
        </div>
    </div>
</div>
<div class="mb-3">
    <label class="form-label" for="noteInput">メモ</label>
    <textarea class="form-control" id="noteInput" rows="2"></textarea>
    <button class="btn btn-secondary mt-2" id="noteSaveBtn">
        <i class="bi bi-save"></i> メモ保存
    </button>
</div>
<div class="row mb-3">
    <div class="col-auto">
        <label class="form-label" for="breakMinutesInput">休憩(分)</label>
        <input class="form-control" id="breakMinutesInput" min="0" style="width:120px;" type="number" value="60"/>
    </div>
    <div class="col d-flex align-items-end">
        <button class="btn btn-outline-secondary" id="breakApplyBtn">休憩を保存</button>
    </div>
</div>

<!-- wrap table so buttons can be absolutely positioned to its top-right -->
<div class="table-with-controls">
    <div class="mb-3 d-flex justify-content-end" id="reportButtons">
        <div class="d-flex gap-2 flex-wrap flex-md-nowrap align-items-center">
            <button class="btn btn-primary" id="downloadCsvBtn" style="min-width:110px;" type="button">CSV
                ダウンロード
            </button>
            <button class="btn btn-secondary" id="downloadPdfBtn" style="min-width:110px;" type="button">PDF
                ダウンロード
            </button>
            <button class="btn btn-success" id="downloadXlsxBtn" style="min-width:120px;" type="button">Excel
                ダウンロード
            </button>
        </div>
    </div>
    <div class="mb-2 w-100" id="reportMessageContainer">
        <div class="text-muted small" id="reportMessage"></div>
    </div>
    <!-- spacer for mobile -->
    <div class="clearfix"></div>

    <table class="table table-sm" id="historyTable">
        <thead>
        <tr>
            <th>日付</th>
            <th>開始</th>
            <th>終了</th>
            <th>休憩(分)</th>
            <th>稼働(分)</th>
            <th>実働(分)</th>
            <th>メモ</th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>
<script src="/webjars/bootstrap/5.3.8/js/bootstrap.bundle.min.js"></script>
<script>
    const statusEl = document.getElementById('status');
    const historyTBody = document.querySelector('#historyTable tbody');
    const clockInBtn = document.getElementById('clockInBtn');
    const clockOutBtn = document.getElementById('clockOutBtn');
    const registerBtn = document.getElementById('registerBtn');
    const noteInput = document.getElementById('noteInput');
    const noteSaveBtn = document.getElementById('noteSaveBtn');
    const breakMinutesInput = document.getElementById('breakMinutesInput');
    const breakApplyBtn = document.getElementById('breakApplyBtn');

    let currentEntry = null; // 現在の勤怠レコード保持

    function fmt(t) {
        return t ? t : ''
    }

    function fmtHM(m) {
        if (m == null || m === '') return '';
        const v = parseInt(m, 10);
        if (isNaN(v)) return '';
        const h = Math.floor(v / 60);
        const mm = v % 60;
        return `${h}時間${mm}分`;
    }

    function renderRow(entry) {
        const tr = document.createElement('tr');
        const duration = entry.durationMinutes ?? (entry.startTime && entry.endTime ? diffMinutes(entry.startTime, entry.endTime) : null);
        const working = entry.workingMinutes ?? (duration != null ? Math.max(duration - (entry.breakMinutes || 0), 0) : null);
        tr.innerHTML = `<td>${entry.workDate}</td>` +
            `<td>${fmt(entry.startTime)}</td>` +
            `<td>${fmt(entry.endTime)}</td>` +
            `<td>${entry.breakMinutes ?? ''}</td>` +
            `<td>${duration != null ? fmtHM(duration) : ''}</td>` +
            `<td>${working != null ? fmtHM(working) : ''}</td>` +
            `<td>${entry.note || ''}</td>`;
        return tr;
    }

    function diffMinutes(start, end) {
        if (!start || !end) return null;
        if (!/^\d\d:\d\d$/.test(start) || !/^\d\d:\d\d$/.test(end)) return null;
        const [sh, sm] = start.split(':').map(Number);
        const [eh, em] = end.split(':').map(Number);
        const s = sh * 60 + sm;
        const e = eh * 60 + em;
        let d = e - s;
        if (d < 0) {
            // 翌日跨ぎ想定 (最大24h)
            d = e + 1440 - s;
            if (d <= 0 || d > 1440) return null;
        }
        return d;
    }

    // リアルタイム表示更新
    function updateRealtimeMetrics() {
        if (!currentEntry) return;
        const start = currentEntry.startTime;
        const end = currentEntry.endTime;
        const breakVal = parseInt(breakMinutesInput.value || '0', 10);
        let duration = null;
        let working = null;
        if (start && end) {
            duration = diffMinutes(start, end);
            if (duration != null) working = Math.max(duration - breakVal, 0);
        }
        const extra = duration != null
            ? ` / 稼働:${fmtHM(duration)} 実働:${working != null ? fmtHM(working) : ''} 休憩:${breakVal}分`
            : ` / 休憩:${breakVal}分`;
        if (statusEl.dataset.base) {
            statusEl.innerHTML = statusEl.dataset.base + extra;
        } else {
            statusEl.dataset.base = statusEl.innerHTML;
            statusEl.innerHTML = statusEl.dataset.base + extra;
        }
    }

    // 既存 updateStatus の末尾で base キャッシュ化を追加
    const _origUpdateStatus = updateStatus;
    updateStatus = function (entry) {
        _origUpdateStatus(entry);
        // base 再設定
        statusEl.dataset.base = statusEl.innerHTML;
        updateRealtimeMetrics();
    };

    async function loadRange() {
        const today = new Date().toISOString().substring(0, 10);
        const resp = await fetch(`/timesheet/api?from=${today}&to=${today}`);
        if (!resp.ok) {
            return;
        }
        const list = await resp.json();
        historyTBody.innerHTML = '';
        list.forEach(e => historyTBody.appendChild(renderRow(e)));
        updateStatus(list[0]);
    }

    async function loadToday() {
        const resp = await fetch('/timesheet/api/today');
        if (!resp.ok) {
            statusEl.textContent = '取得失敗';
            return;
        }
        const entry = await resp.json();
        updateStatus(entry);
    }

    function updateStatus(entry) {
        currentEntry = entry;
        if (!entry) {
            statusEl.textContent = '未出勤';
            registerBtn.innerHTML = '<i class="bi bi-box-arrow-in-right"></i> 出勤登録';
            registerBtn.className = 'btn btn-success btn-lg';
            return;
        }
        if (entry.endTime == null) {
            statusEl.innerHTML = `<span class='working'>勤務中</span> 開始: ${entry.startTime}`;
            registerBtn.innerHTML = '<i class="bi bi-box-arrow-left"></i> 退勤登録';
            registerBtn.className = 'btn btn-danger btn-lg';
        } else {
            statusEl.textContent = `完了 開始: ${entry.startTime} / 終了: ${entry.endTime}`;
            registerBtn.innerHTML = '<i class="bi bi-check-circle"></i> 登録済';
            registerBtn.className = 'btn btn-secondary btn-lg';
            registerBtn.disabled = true;
        }
        noteInput.value = entry.note || '';
    }

    function getCsrf() {
        const t = document.querySelector('meta[name="_csrf"]');
        const h = document.querySelector('meta[name="_csrf_header"]');
        return t && h ? {token: t.getAttribute('content'), header: h.getAttribute('content')} : null;
    }

    async function doPost(url, bodyObj) {
        const csrf = getCsrf();
        const headers = {};
        if (bodyObj) {
            headers['Content-Type'] = 'application/json';
        }
        if (csrf) {
            headers[csrf.header] = csrf.token;
        }
        const resp = await fetch(url, {
            method: 'POST',
            headers,
            body: bodyObj ? JSON.stringify(bodyObj) : undefined,
            credentials: 'same-origin'
        });
        if (!resp.ok) {
            const txt = await resp.text();
            statusEl.innerHTML = `<div class='text-danger'>失敗 (${resp.status}) ${txt.substring(0, 120)}</div>`;
            throw new Error('POST failed ' + resp.status);
        }
        return resp.json();
    }

    registerBtn.onclick = async () => {
        try {
            if (!currentEntry || currentEntry.startTime == null) {
                // 未出勤 → 出勤
                const data = await doPost('/timesheet/api/clock-in');
                updateStatus(data);
                loadRange();
            } else if (currentEntry.endTime == null) {
                // 勤務中 → 退勤
                const data = await doPost('/timesheet/api/clock-out');
                updateStatus(data);
                loadRange();
            }
        } catch (e) {
            console.error(e);
        }
    };

    clockInBtn.onclick = async () => {
        try {
            const data = await doPost('/timesheet/api/clock-in');
            updateStatus(data);
            loadRange();
        } catch (e) {
            console.error(e);
        }
    };
    clockOutBtn.onclick = async () => {
        try {
            const data = await doPost('/timesheet/api/clock-out');
            updateStatus(data);
            loadRange();
        } catch (e) {
            console.error(e);
        }
    };

    let noteDirty = false;
    let autoSaveTimer = null;
    let lastSentValue = '';

    function markDirty() {
        if (!noteDirty) {
            noteDirty = true;
            statusEl.insertAdjacentHTML('beforeend', " <small class='text-warning' id='noteDirtyMark'>(未保存)</small>");
        }
    }

    function clearDirty() {
        noteDirty = false;
        const mk = document.getElementById('noteDirtyMark');
        if (mk) mk.remove();
    }

    function scheduleAutoSave() {
        if (autoSaveTimer) {
            clearTimeout(autoSaveTimer);
        }
        autoSaveTimer = setTimeout(async () => {
            const val = noteInput.value;
            if (val === lastSentValue) {
                clearDirty();
                return;
            }
            try {
                await doPost('/timesheet/api/note', {note: val});
                lastSentValue = val;
                clearDirty();
            } catch (e) {
                console.error(e);
            }
        }, 1500); // 1.5秒デバウンス
    }

    noteInput.addEventListener('input', () => {
        markDirty();
        scheduleAutoSave();
    });
    window.addEventListener('beforeunload', () => {
        if (noteDirty) {
            const note = encodeURIComponent(noteInput.value);
            const url = `/timesheet/api/note/saveBeacon?note=${note}`;
            navigator.sendBeacon && navigator.sendBeacon(url);
        }
    });

    // 既存ボタンによる明示保存も残す
    noteSaveBtn.onclick = async () => {
        try {
            const data = await doPost('/timesheet/api/note', {note: noteInput.value});
            lastSentValue = noteInput.value;
            updateStatus(data);
            loadRange();
            clearDirty();
        } catch (e) {
            console.error(e);
        }
    };

    function handleIncoming(entry) {
        const incomingNote = entry.note || '';
        if (incomingNote !== noteInput.value) {
            noteInput.value = incomingNote;
            lastSentValue = incomingNote;
            clearDirty();
        }
    }

    function createSse() {
        const es = new EventSource('/timesheet/api/stream');
        let backoff = 1000; // 1s から指数的に
        es.addEventListener('heartbeat', () => {/* no-op keepalive */
        });
        ['clock-in', 'clock-out', 'note', 'break'].forEach(ev => {
            es.addEventListener(ev, e => {
                try {
                    const data = JSON.parse(e.data);
                    currentEntry = data;
                    updateStatus(data);
                    handleIncoming(data);
                    loadRange();
                } catch (err) {
                }
            });
        });
        es.onerror = () => {
            es.close();
            setTimeout(() => {
                createSse();
                backoff = Math.min(backoff * 2, 30000);
            }, backoff);
        };
        return es;
    }

    function openStream() {
        window.__ts_es && window.__ts_es.close();
        window.__ts_es = createSse();
    }

    openStream();
    loadRange();
    loadToday();

    breakMinutesInput.addEventListener('input', () => {
        updateRealtimeMetrics();
        scheduleBreakAutoSave();
    });
    let breakTimer = null;

    function scheduleBreakAutoSave() {
        if (breakTimer) clearTimeout(breakTimer);
        breakTimer = setTimeout(async () => {
            await saveBreak();
        }, 800); // 0.8秒デバウンス
    }

    async function saveBreak() {
        const minutes = parseInt(breakMinutesInput.value || '0', 10);
        try {
            const updated = await doPost('/timesheet/api/break', {minutes});
            currentEntry = updated; // 休憩更新後の最新
            loadRange();
            updateRealtimeMetrics();
        } catch (e) {
            console.error(e);
        }
    }

    breakApplyBtn.addEventListener('click', async () => {
        await saveBreak();
    });

    async function downloadReport(format) {
        try {
            const ym = new Date().toISOString().substring(0, 7); // YYYY-MM
            const [y, m] = ym.split('-').map(Number);
            const from = `${y}-${String(m).padStart(2, '0')}-01`;
            const last = new Date(y, m, 0).getDate();
            const to = `${y}-${String(m).padStart(2, '0')}-${String(last).padStart(2, '0')}`;
            const username = (window.currentUserName || 'user1'); // ensure backend gets username
            const url = `/timesheet/report/${format}?username=${encodeURIComponent(username)}&from=${from}&to=${to}`;
            const resp = await fetch(url, {credentials: 'same-origin'});
            if (!resp.ok) {
                alert('レポートの取得に失敗しました');
                return;
            }
            const blob = await resp.blob();
            const disposition = resp.headers.get('Content-Disposition') || '';
            const filenameMatch = /filename=(.+)$/.exec(disposition);
            const filename = filenameMatch ? filenameMatch[1] : `timesheet.${format}`;
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename.replace(/"/g, '');
            document.body.appendChild(link);
            link.click();
            link.remove();
        } catch (err) {
            console.error('ダウンロード失敗', err);
            alert('ダウンロードに失敗しました');
        }
    }

    // Ensure report buttons are visible and attach improved handlers
    (function ensureReportButtons() {
        try {
            const container = document.getElementById('reportButtons');
            const messageEl = document.getElementById('reportMessage');
            if (!container) return;
            // Make sure it's visible and on top (position comes from CSS so absolute works)
            container.style.display = 'block';
            container.style.zIndex = 999;
            if (messageEl) {
                messageEl.textContent = '';
            }

            const setMsg = (txt, kind) => {
                if (!messageEl) return;
                messageEl.textContent = txt;
                messageEl.className = 'mt-2 ' + (kind === 'error' ? 'text-danger' : (kind === 'ok' ? 'text-success' : 'text-muted'));
            };

            const csvBtn = document.getElementById('downloadCsvBtn');
            const pdfBtn = document.getElementById('downloadPdfBtn');
            const xlsxBtn = document.getElementById('downloadXlsxBtn');

            const attach = (btn, fmt) => {
                if (!btn) return;
                btn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    btn.disabled = true;
                    const origText = btn.innerHTML;
                    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> 生成中';
                    setMsg('レポートを生成しています...', 'info');
                    try {
                        await downloadReport(fmt);
                        setMsg('ダウンロード完了', 'ok');
                    } catch (err) {
                        console.error(err);
                        setMsg('ダウンロードに失敗しました', 'error');
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = origText;
                    }
                });
            };

            attach(csvBtn, 'csv');
            attach(pdfBtn, 'pdf');
            attach(xlsxBtn, 'xlsx');
        } catch (e) {
            console.warn('report buttons init failed', e);
        }
    })();

    // Debug / safety: on DOMContentLoaded ensure buttons exist and are visible
    window.addEventListener('DOMContentLoaded', () => {
        try {
            const ids = ['downloadCsvBtn', 'downloadPdfBtn', 'downloadXlsxBtn'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) {
                    console.warn(`Report button not found: ${id}`);
                    return;
                }
                // remove common hiding classes and force visible
                el.classList.remove('d-none');
                el.style.display = el.style.display || 'inline-block';
                el.style.visibility = 'visible';
                el.setAttribute('aria-hidden', 'false');
                console.info(`Report button present: ${id}`);
            });
        } catch (e) {
            console.error('report buttons visibility check failed', e);
        }
    });

</script>
</body>
</html>
