<div th:fragment="content">
    <div class="container-fluid">
        <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
            <h2 class="mb-0" th:text="${monthDisplay}">2025年11月</h2>
            <div class="d-flex gap-2 align-items-center">
                <button class="btn btn-sm btn-outline-secondary" id="prevMonth" title="前の月" type="button">
                    <i class="bi bi-chevron-left"></i>
                </button>
                <input class="form-control form-control-sm" id="monthInput" style="width:160px;"
                       th:value="${yearMonthValue}" title="表示する月" type="month">
                <button class="btn btn-sm btn-outline-secondary" id="nextMonth" title="次の月" type="button">
                    <i class="bi bi-chevron-right"></i>
                </button>
            </div>
        </div>

        <!-- controls -->
        <div class="controls mb-3 d-flex gap-3 align-items-center flex-wrap">
            <div class="d-flex gap-2 align-items-center">
                <label class="form-label mb-0 small" for="defaultStart">出勤デフォルト：</label>
                <input class="form-control form-control-sm" id="defaultStart" style="width:110px;"
                       title="出勤時刻のデフォルト値"
                       type="time" value="09:00">
                <label class="form-label mb-0 small" for="defaultEnd">退勤デフォルト：</label>
                <input class="form-control form-control-sm" id="defaultEnd" style="width:110px;"
                       title="退勤時刻のデフォルト値"
                       type="time" value="18:00">
                <label class="form-label mb-0 small" for="defaultBreak">休憩(分)デフォルト：</label>
                <input class="form-control form-control-sm" id="defaultBreak" min="0" style="width:90px;" type="number"
                       value="60">
                <button class="btn btn-sm btn-secondary" id="applyDefaults">空セルに適用</button>
            </div>
        </div>

        <div class="alert alert-success py-2 px-3 mb-3 d-flex align-items-center gap-2" role="alert">
            <i class="bi bi-check-circle"></i>
            <small><strong>リアルタイム保存有効：</strong> 時刻を設定すると自動的に保存されます</small>
        </div>

        <!-- テーブルヘッダ拡張 -->
        <div class="table-responsive" style="max-height: calc(100vh - 280px); overflow-y: auto;">
            <table class="table table-sm table-bordered table-hover" id="workTable">
                <thead class="table-light">
                <tr>
                    <th style="width:220px;">日付</th>
                    <th style="width:90px;">出勤</th>
                    <th style="width:90px;">退勤</th>
                    <th style="width:80px;">休憩</th>
                    <th style="width:90px;">稼働</th>
                    <th style="width:90px;">実働</th>
                </tr>
                </thead>
                <tbody id="tableBody">
                <tr th:classappend="${d == T(java.time.LocalDate).now()} ? 'table-primary' : ''" th:each="d : ${dates}">
                    <td class="date-cell" th:data-iso="${#temporals.format(d,'yyyy-MM-dd')}">
                        <span th:text="${#temporals.format(d,'MM/dd (E)')}">11/24 (月)</span>
                    </td>
                    <td class="time-cell" data-type="start"></td>
                    <td class="time-cell" data-type="end"></td>
                    <td class="break-cell" contenteditable="true"></td>
                    <td class="duration-cell"></td>
                    <td class="working-cell"></td>
                </tr>
                </tbody>
            </table>
        </div>

        <p class="text-muted small mt-3">※
            出勤・退勤のセルをクリックして時刻を設定してください。祝日は自動で表示されます。</p>
    </div>

    <!-- Time Picker -->
    <div aria-hidden="true" class="time-picker" id="timePicker" style="display:none;">
        <div class="picker-header">
            <div>
                <span class="selected-date" id="selectedDateLabel">日付: —</span>
                <span aria-hidden="true" class="selected-holiday" id="holidayLabel" style="display:none;"></span>
            </div>
            <div class="label-small" id="cellTypeLabel">種類: —</div>
        </div>

        <div class="display" id="timeDisplay">00:00</div>
        <div class="mode" id="modeLabel">時を設定してください (0-23)</div>

        <div class="clock" id="clock">
            <div class="hand" id="hand"></div>
            <div class="center-dot"></div>
            <div class="drag-area" id="dragArea"></div>
        </div>
    </div>

    <script th:inline="javascript">
        /*<![CDATA[*/
        (function () {
            // 既存変数取得
            const defaultStart = document.getElementById('defaultStart');
            const defaultEnd = document.getElementById('defaultEnd');
            const defaultBreak = document.getElementById('defaultBreak');
            const applyDefaultsBtn = document.getElementById('applyDefaults');
            const picker = document.getElementById('timePicker');
            const display = document.getElementById('timeDisplay');
            const hand = document.getElementById('hand');
            const modeLabel = document.getElementById('modeLabel');
            const dragArea = document.getElementById('dragArea');
            const clock = document.getElementById('clock');
            const selectedDateLabel = document.getElementById('selectedDateLabel');
            const cellTypeLabel = document.getElementById('cellTypeLabel');
            const holidayLabel = document.getElementById('holidayLabel');
            const monthInput = document.getElementById('monthInput');
            const prevBtn = document.getElementById('prevMonth');
            const nextBtn = document.getElementById('nextMonth');

            let currentCell = null;
            let selectingHour = true;
            let hour = 0;
            let minute = 0;
            let dragStarted = false;
            let dragStartTime = 0;

            const holidayCache = {};
            let autoSaveTimer = null;
            const AUTO_SAVE_DELAY = 800; // 0.8秒後に自動保存

            async function fetchHolidays(year) {
                if (holidayCache[year]) return holidayCache[year];
                try {
                    const res = await fetch(`https://date.nager.at/api/v3/PublicHolidays/${year}/JP`);
                    if (!res.ok) {
                        holidayCache[year] = {};
                        return {};
                    }
                    const data = await res.json();
                    const map = {};
                    for (const h of data) {
                        map[h.date] = h.localName || h.name || '';
                    }
                    holidayCache[year] = map;
                    return map;
                } catch (err) {
                    console.warn('祝日取得失敗:', err);
                    holidayCache[year] = {};
                    return {};
                }
            }

            (async function init() {
                const year = new Date().getFullYear();
                const holidayMap = await fetchHolidays(year);

                document.querySelectorAll('td.date-cell').forEach(cell => {
                    const iso = cell.dataset.iso;
                    if (holidayMap[iso]) {
                        const hspan = cell.querySelector('.holiday');
                        if (hspan) {
                            hspan.textContent = `祝: ${holidayMap[iso]}`;
                            hspan.style.display = '';
                        }
                    }
                });
            })();

            function computeDuration(start, end) {
                if (!start || !end) return '';
                if (!/^\d\d:\d\d$/.test(start) || !/^\d\d:\d\d$/.test(end)) return '';
                const [sh, sm] = start.split(':').map(Number);
                const [eh, em] = end.split(':').map(Number);
                const diff = (eh * 60 + em) - (sh * 60 + sm);
                return diff >= 0 ? diff : '';
            }

            function fmtHM(m) {
                if (m == null || m === '') return '';
                const v = parseInt(m, 10);
                if (isNaN(v)) return '';
                const h = Math.floor(v / 60);
                const mm = v % 60;
                return `${h}時間${mm}分`;
            }

            // updateRowMetrics 内の表示を修正
            function updateRowMetrics(row) {
                const start = row.querySelector('.time-cell[data-type="start"]').textContent.trim();
                const end = row.querySelector('.time-cell[data-type="end"]').textContent.trim();
                const breakVal = parseInt(row.querySelector('.break-cell').textContent.trim() || '0', 10);
                const duration = computeDuration(start, end);
                const working = duration !== '' ? Math.max(duration - breakVal, 0) : '';
                row.querySelector('.duration-cell').textContent = duration !== '' ? fmtHM(duration) : '';
                row.querySelector('.working-cell').textContent = working !== '' ? fmtHM(working) : '';
            }

            // loadTimesheetData 内で既存値埋め時にもフォーマット反映
            const _origLoad = typeof loadTimesheetData === 'function' ? loadTimesheetData : null;
            if (_origLoad) {
                loadTimesheetData = async function (recalc = true) {
                    await _origLoad(recalc);
                    if (recalc) {
                        document.querySelectorAll('#tableBody tr').forEach(updateRowMetrics);
                    }
                };
            }

            applyDefaultsBtn.addEventListener('click', async () => {
                const s = defaultStart.value;
                const e = defaultEnd.value;
                const b = defaultBreak.value.trim();
                const batch = [];
                document.querySelectorAll('#tableBody tr').forEach(row => {
                    const sc = row.querySelector('.time-cell[data-type="start"]');
                    const ec = row.querySelector('.time-cell[data-type="end"]');
                    const bc = row.querySelector('.break-cell');
                    if (sc.textContent.trim() === '') sc.textContent = s;
                    if (ec.textContent.trim() === '') ec.textContent = e;
                    if (bc.textContent.trim() === '' && b !== '') bc.textContent = b;
                    updateRowMetrics(row);
                    const iso = row.querySelector('.date-cell').dataset.iso;
                    batch.push({
                        workDate: iso,
                        startTime: sc.textContent.trim() || null,
                        endTime: ec.textContent.trim() || null,
                        breakMinutes: bc.textContent.trim() || null
                    });
                });
                if (batch.length > 0) {
                    await saveBatch(batch);
                }
            });

            function getCsrf() {
                const t = document.querySelector('meta[name="_csrf"]');
                const h = document.querySelector('meta[name="_csrf_header"]');
                return t && h ? {token: t.content, header: h.content} : null;
            }

            async function saveBatch(entries) {
                const csrf = getCsrf();
                const headers = {'Content-Type': 'application/json'};
                if (csrf) headers[csrf.header] = csrf.token;
                try {
                    const resp = await fetch('/timesheet/api/batch', {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({entries}),
                        credentials: 'same-origin'
                    });
                    if (!resp.ok) {
                        console.warn('一括保存失敗', resp.status);
                    }
                } catch (e) {
                    console.error('一括保存エラー', e);
                }
            }

            // 時刻セルクリック (既存が途中まで記述されていた場合補完)
            document.getElementById('workTable').addEventListener('click', e => {
                const cell = e.target.closest('td.time-cell');
                if (!cell) return;
                document.querySelectorAll('td.time-cell.active').forEach(c => c.classList.remove('active'));
                cell.classList.add('active');
                currentCell = cell;
                const type = cell.dataset.type;
                const row = cell.parentElement;
                const dateCell = row.querySelector('.date-cell');
                const iso = dateCell ? dateCell.dataset.iso : '';
                selectedDateLabel.textContent = '日付: ' + iso;
                cellTypeLabel.textContent = '種類: ' + (type === 'start' ? '出勤' : '退勤');
                holidayLabel.style.display = 'none';
                const init = cell.textContent.trim();
                if (/^\d\d:\d\d$/.test(init)) {
                    [hour, minute] = init.split(':').map(Number);
                } else {
                    const def = (type === 'start' ? defaultStart.value : defaultEnd.value);
                    if (/^\d\d:\d\d$/.test(def)) {
                        [hour, minute] = def.split(':').map(Number);
                    } else {
                        hour = 9;
                        minute = 0;
                    }
                }
                selectingHour = true;
                modeLabel.textContent = '時を設定してください (0-23)';
                updateDisplay();
                setHand();
                const r = cell.getBoundingClientRect();
                picker.style.left = Math.max(8, r.left) + 'px';
                picker.style.top = (r.bottom + 6) + 'px';
                picker.style.display = 'block';
                picker.setAttribute('aria-hidden', 'false');
            });

            function updateDisplay() {
                display.textContent = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
            }

            function setHand() {
                const angle = selectingHour ? (hour % 24) * 15 : minute * 6;
                hand.style.transform = `rotate(${angle}deg)`;
            }

            dragArea.addEventListener('mousedown', () => {
                dragStarted = false;
                dragStartTime = Date.now();
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', onDrop);
            });

            function onDrag(ev) {
                dragStarted = true;
                const rect = clock.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const dx = ev.clientX - cx;
                const dy = ev.clientY - cy;
                const angle = (Math.atan2(dy, dx) * 180 / Math.PI + 90 + 360) % 360;
                hand.style.transform = `rotate(${angle}deg)`;
                if (selectingHour) {
                    hour = Math.round(angle / 15) % 24;
                } else {
                    minute = Math.round(angle / 6) % 60;
                }
                updateDisplay();
            }

            function onDrop() {
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDrop);
                if (selectingHour) {
                    selectingHour = false;
                    modeLabel.textContent = '分を設定してください (0-59)';
                    setHand();
                    return;
                }
                if (currentCell) {
                    currentCell.textContent = display.textContent;
                    currentCell.classList.remove('active');
                    updateRowMetrics(currentCell.parentElement);
                    scheduleAutoSave(currentCell);
                }
                picker.style.display = 'none';
                picker.setAttribute('aria-hidden', 'true');
            }

            document.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    picker.style.display = 'none';
                    picker.setAttribute('aria-hidden', 'true');
                    document.querySelectorAll('td.time-cell.active').forEach(c => c.classList.remove('active'));
                }
            });
            document.addEventListener('mousedown', e => {
                if (picker.contains(e.target) || e.target.closest('td.time-cell')) return;
                picker.style.display = 'none';
                picker.setAttribute('aria-hidden', 'true');
                document.querySelectorAll('td.time-cell.active').forEach(c => c.classList.remove('active'));
            });

            function scheduleAutoSave(cell) {
                if (autoSaveTimer) clearTimeout(autoSaveTimer);
                autoSaveTimer = setTimeout(() => performAutoSave(cell), AUTO_SAVE_DELAY);
            }

            async function performAutoSave(cell) {
                const row = cell.parentElement;
                const iso = row.querySelector('.date-cell').dataset.iso;
                const sc = row.querySelector('.time-cell[data-type="start"]').textContent.trim();
                const ec = row.querySelector('.time-cell[data-type="end"]').textContent.trim();
                const b = row.querySelector('.break-cell').textContent.trim();
                await saveBatch([{workDate: iso, startTime: sc || null, endTime: ec || null, breakMinutes: b || null}]);
                loadTimesheetData(false);
            }

            // 休憩セル編集後保存
            document.getElementById('workTable').addEventListener('blur', async e => {
                const cell = e.target.closest('.break-cell');
                if (!cell) return;
                updateRowMetrics(cell.parentElement);
                const row = cell.parentElement;
                const iso = row.querySelector('.date-cell').dataset.iso;
                const sc = row.querySelector('.time-cell[data-type="start"]').textContent.trim();
                const ec = row.querySelector('.time-cell[data-type="end"]').textContent.trim();
                const b = cell.textContent.trim();
                await saveBatch([{workDate: iso, startTime: sc || null, endTime: ec || null, breakMinutes: b || null}]);
            }, true);

            // 補足: 月次行再生成と月末日計算関数を定義（欠落によるReferenceError対応）
            function dayLabel(date) {
                const wd = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];
                const mm = String(date.getMonth() + 1).padStart(2, '0');
                const dd = String(date.getDate()).padStart(2, '0');
                return `${mm}/${dd} (${wd})`;
            }

            function calcLastDay(year, month1) {
                // month1 は 1始まり。Date は0始まりなので month1 をそのまま +1 した値で 0 日指定で当月末取得。
                return new Date(year, month1, 0).getDate(); // new Date(year, month1, 0) は (month1-1)月の末日 → month1引数を+1で呼び出す運用に変更済み
            }

            function rebuildRows(ym) {
                const tbody = document.getElementById('tableBody');
                if (!tbody) return;
                const [y, mStr] = ym.split('-');
                const yNum = Number(y);
                const mNum = Number(mStr);
                if (!yNum || !mNum) return;
                const lastDay = calcLastDay(yNum, mNum + 1); // 本来の月の末日
                tbody.innerHTML = '';
                for (let d = 1; d <= lastDay; d++) {
                    const iso = `${yNum}-${String(mNum).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                    const date = new Date(yNum, mNum - 1, d);
                    const tr = document.createElement('tr');
                    if (iso === new Date().toISOString().substring(0, 10)) tr.classList.add('table-primary');
                    tr.innerHTML = `<td class=\"date-cell\" data-iso=\"${iso}\"><span>${dayLabel(date)}</span><span class=\"holiday\" style=\"display:none;\"></span></td>` +
                        `<td class=\"time-cell\" data-type=\"start\"></td>` +
                        `<td class=\"time-cell\" data-type=\"end\"></td>` +
                        `<td class=\"break-cell\" contenteditable=\"true\"></td>` +
                        `<td class=\"duration-cell\"></td>` +
                        `<td class=\"working-cell\"></td>`;
                    tbody.appendChild(tr);
                }
                // 祝日再表示
                (async () => {
                    try {
                        const holidayMap = holidayCache[yNum] || await fetchHolidays(yNum);
                        tbody.querySelectorAll('.date-cell').forEach(cell => {
                            const iso = cell.dataset.iso;
                            if (holidayMap[iso]) {
                                const h = cell.querySelector('.holiday');
                                h.textContent = `祝: ${holidayMap[iso]}`;
                                h.style.display = '';
                            }
                        });
                    } catch (e) {
                        console.warn('祝日再表示失敗', e);
                    }
                })();
            }

            async function loadTimesheetData(recalc = true) {
                const [year, month] = monthInput.value.split('-').map(Number);
                const lastDay = calcLastDay(year, month + 1); // 修正: month+1 を渡す
                const from = `${year}-${String(month).padStart(2, '0')}-01`;
                const to = `${year}-${String(month).padStart(2, '0')}-${String(lastDay).padStart(2, '0')}`;
                console.debug('[TS] loadTimesheetData month=', month, 'range', from, '->', to);
                try {
                    const resp = await fetch(`/timesheet/api?from=${from}&to=${to}`, {credentials: 'same-origin'});
                    if (!resp.ok) {
                        if (resp.status !== 404) console.warn('読込失敗', resp.status);
                        return;
                    }
                    const entries = await resp.json();
                    const map = {};
                    entries.forEach(e => {
                        map[e.workDate] = {
                            start: e.startTime,
                            end: e.endTime,
                            break: e.breakMinutes,
                            duration: e.durationMinutes,
                            working: e.workingMinutes
                        };
                    });
                    document.querySelectorAll('#tableBody tr').forEach(row => {
                        const iso = row.querySelector('.date-cell').dataset.iso;
                        const data = map[iso];
                        if (!data) return;
                        if (data.start) row.querySelector('.time-cell[data-type="start"]').textContent = data.start;
                        if (data.end) row.querySelector('.time-cell[data-type="end"]').textContent = data.end;
                        if (data.break != null) row.querySelector('.break-cell').textContent = data.break;
                        row.querySelector('.duration-cell').textContent = data.duration != null ? data.duration : '';
                        row.querySelector('.working-cell').textContent = data.working != null ? data.working : '';
                        if (recalc) updateRowMetrics(row);
                    });
                } catch (e) {
                    console.error('読込エラー', e);
                }
            }

            // 月移動
            // 旧ハンドラ (重複/誤算出) を無効化
            // monthInput && monthInput.addEventListener('change', () => loadTimesheetData());
            // prevBtn && prevBtn.addEventListener('click', () => { /* removed */ });
            // nextBtn && nextBtn.addEventListener('click', () => { /* removed */ });

            function setMonth(year, month) {
                // 正規化 (1-12)
                if (month < 1) {
                    year -= 1;
                    month = 12;
                }
                if (month > 12) {
                    year += 1;
                    month = 1;
                }
                const ym = `${year}-${String(month).padStart(2, '0')}`;
                if (monthInput) monthInput.value = ym;
                rebuildRows(ym);
                loadTimesheetData();
            }

            // 新しい前月・次月ボタンハンドラ
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (!monthInput) return;
                    const [y, m] = monthInput.value.split('-').map(Number);
                    setMonth(y, m - 1);
                });
            }
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (!monthInput) return;
                    const [y, m] = monthInput.value.split('-').map(Number);
                    setMonth(y, m + 1);
                });
            }
            if (monthInput) {
                monthInput.addEventListener('change', () => {
                    const [y, m] = monthInput.value.split('-').map(Number);
                    setMonth(y, m);
                });
            }
            // 初期構築 (既存 monthInput.value 利用)
            if (monthInput) {
                rebuildRows(monthInput.value);
                loadTimesheetData();
            }
        })();
        /*]]>*/
    </script>
</div>
