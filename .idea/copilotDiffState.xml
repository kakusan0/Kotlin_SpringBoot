<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt" />
              <option name="originalContent" value="package com.example.demo.config&#10;&#10;import io.undertow.server.DefaultByteBufferPool&#10;import io.undertow.websockets.jsr.WebSocketDeploymentInfo&#10;import org.springframework.boot.web.embedded.undertow.UndertowDeploymentInfoCustomizer&#10;import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory&#10;import org.springframework.context.annotation.Bean&#10;import org.springframework.context.annotation.Configuration&#10;import org.springframework.core.env.Environment&#10;import org.springframework.util.unit.DataSize&#10;&#10;@Configuration&#10;class UndertowWebSocketConfig(&#10;    private val env: Environment&#10;) {&#10;&#10;    @Bean&#10;    fun undertowServletWebServerFactory(): UndertowServletWebServerFactory {&#10;        val factory = UndertowServletWebServerFactory()&#10;&#10;        val customizer = UndertowDeploymentInfoCustomizer { di -&gt;&#10;            // Undertow の WebSocket 用バッファプールを設定（警告 UT026010 の解消）&#10;            val direct = true // 直接バッファ（GC 負荷軽減）&#10;            val dataSize: DataSize = env.getProperty(&#10;                &quot;server.undertow.buffer-size&quot;,&#10;                DataSize::class.java,&#10;                DataSize.ofKilobytes(16)&#10;            )&#10;            val bufferSize: Int = dataSize.toBytes().coerceAtMost(Int.MAX_VALUE.toLong()).toInt()&#10;            val wsInfo = WebSocketDeploymentInfo()&#10;            wsInfo.buffers = DefaultByteBufferPool(direct, bufferSize)&#10;            (di as io.undertow.servlet.api.DeploymentInfo)&#10;                .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, wsInfo)&#10;        }&#10;&#10;        factory.setDeploymentInfoCustomizers(listOf(customizer))&#10;        return factory&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo.config&#13;&#10;&#13;&#10;import org.springframework.context.annotation.Configuration&#13;&#10;&#13;&#10;@Configuration&#13;&#10;class UndertowWebSocketConfig {&#13;&#10;    // Undertow を削除したため本クラスは空のプレースホルダです。&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/static/js/pwgen.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/static/js/pwgen.js" />
              <option name="originalContent" value="// pwgen.js - externalized Vanilla JS for password generator&#10;// This file contains the optimized JS previously embedded in the dashboard fragment.&#10;&#10;// global guard to prevent duplicate attachment across multiple init calls&#10;if (!window.__pwgen) window.__pwgen = { listenersAttached: false };&#10;&#10;function initPwgen() {&#10;  console.log('pwgen.js: initPwgen start');&#10;  // prevent tight re-entry: ignore repeated inits within short window&#10;  try {&#10;    var now = Date.now();&#10;    // ensure shared lastInit exists&#10;    if (typeof window.__pwgen.lastInit !== 'number') window.__pwgen.lastInit = 0;&#10;    if (window.__pwgen.lastInit &amp;&amp; now - window.__pwgen.lastInit &lt; 250) {&#10;      console.log('pwgen.js: init suppressed (debounced)');&#10;      return;&#10;    }&#10;    window.__pwgen.lastInit = now;&#10;  } catch (_) {}&#10;&#10;  // element refs (use let so we can replace nodes safely)&#10;  let lengthEl = document.getElementById('length');&#10;  let lengthValueEl = document.getElementById('length-value');&#10;  let useLower = document.getElementById('use-lower');&#10;  let useUpper = document.getElementById('use-upper');&#10;  let useNum = document.getElementById('use-num');&#10;  let useSymbol = document.getElementById('use-symbol');&#10;  let generateBtn = document.getElementById('generate-btn');&#10;  let copyBtn = document.getElementById('copy-btn');&#10;  let showHideBtn = document.getElementById('show-hide-btn');&#10;&#10;  console.log('pwgen.js: elements', {&#10;    lengthEl: !!lengthEl,&#10;    useLower: !!useLower,&#10;    useUpper: !!useUpper,&#10;    useNum: !!useNum,&#10;    useSymbol: !!useSymbol,&#10;    generateBtn: !!generateBtn&#10;  });&#10;&#10;  let pwVisible = false;&#10;&#10;  // helper: toggle ids&#10;  const toggleIds = ['use-lower', 'use-upper', 'use-num', 'use-symbol'];&#10;&#10;  function getToggleEl(id) {&#10;    return document.getElementById(id);&#10;  }&#10;&#10;  // utility to replace an element with its clone to remove old listeners, returns new element&#10;  function cloneReplace(el) {&#10;    if (!el || !el.parentNode) return el;&#10;    try {&#10;      const newEl = el.cloneNode(true);&#10;      el.parentNode.replaceChild(newEl, el);&#10;      return newEl;&#10;    } catch (e) {&#10;      return el;&#10;    }&#10;  }&#10;&#10;  // length input&#10;  if (lengthEl &amp;&amp; lengthValueEl) {&#10;    // ensure previous listeners removed by cloning&#10;    lengthEl = cloneReplace(lengthEl);&#10;    lengthEl.addEventListener('input', () =&gt; {&#10;      lengthValueEl.textContent = lengthEl.value;&#10;    });&#10;  }&#10;&#10;  // wheel handling with minor throttle&#10;  let wheelQueued = false;&#10;  if (lengthEl) {&#10;    lengthEl.addEventListener('wheel', (e) =&gt; {&#10;      const ev = e;&#10;      const min = Number(lengthEl.min || 4);&#10;      const max = Number(lengthEl.max || 64);&#10;      const step = ev.shiftKey ? 5 : 1;&#10;      let val = Number(lengthEl.value);&#10;      if (ev.deltaY &lt; 0) val = Math.min(max, val + step);&#10;      else val = Math.max(min, val - step);&#10;      if (val !== Number(lengthEl.value)) {&#10;        e.preventDefault();&#10;        if (!wheelQueued) {&#10;          wheelQueued = true;&#10;          requestAnimationFrame(() =&gt; {&#10;            lengthEl.value = val;&#10;            lengthEl.dispatchEvent(new Event('input', {bubbles: true}));&#10;            wheelQueued = false;&#10;          });&#10;        }&#10;      }&#10;    }, {passive: false});&#10;  }&#10;&#10;  // toggle helpers&#10;  function setToggleState(el, on) {&#10;    if (!el) return;&#10;    el.setAttribute('aria-pressed', on ? 'true' : 'false');&#10;    el.dataset.checked = on ? 'ON' : 'OFF';&#10;    el.classList.toggle('opt-on', !!on);&#10;  }&#10;&#10;  function anyToggleOn() {&#10;    return toggleIds.some(id =&gt; {&#10;      const el = getToggleEl(id);&#10;      return el &amp;&amp; el.dataset &amp;&amp; el.dataset.checked === 'ON';&#10;    });&#10;  }&#10;&#10;  function allTogglesOn() {&#10;    return toggleIds.every(id =&gt; {&#10;      const el = getToggleEl(id);&#10;      return el &amp;&amp; el.dataset &amp;&amp; el.dataset.checked === 'ON';&#10;    });&#10;  }&#10;&#10;  function resetPasswordDisplay() {&#10;    // always read fresh elements to avoid stale references&#10;    try {&#10;      const _generatedPassword = document.getElementById('generated-password');&#10;      if (_generatedPassword) _generatedPassword.value = '';&#10;    } catch (_) {&#10;    }&#10;    try {&#10;      const _pwStrength = document.getElementById('pw-strength');&#10;      if (_pwStrength) _pwStrength.style.width = '0%';&#10;    } catch (_) {&#10;    }&#10;    try {&#10;      const _pwStrengthLabel = document.getElementById('pw-strength-label');&#10;      if (_pwStrengthLabel) _pwStrengthLabel.textContent = '';&#10;    } catch (_) {&#10;    }&#10;    try {&#10;      const _pwgenResult = document.getElementById('pwgen-result');&#10;      if (_pwgenResult) _pwgenResult.style.display = 'none';&#10;    } catch (_) {&#10;    }&#10;  }&#10;&#10;  function updateGenerateBtnState() {&#10;    try {&#10;      const btn = document.getElementById('generate-btn');&#10;      if (!btn) return;&#10;      btn.disabled = !anyToggleOn();&#10;    } catch (_) {&#10;    }&#10;  }&#10;&#10;  // generate logic (was missing after refactor)&#10;  function doGenerate() {&#10;    console.log('pwgen.js: doGenerate called, anyToggleOn=', anyToggleOn());&#10;    // query fresh elements to avoid stale references after fragment replacement&#10;    const _lengthEl = document.getElementById('length');&#10;    const _useLower = document.getElementById('use-lower');&#10;    const _useUpper = document.getElementById('use-upper');&#10;    const _useNum = document.getElementById('use-num');&#10;    const _useSymbol = document.getElementById('use-symbol');&#10;    const _generatedPassword = document.getElementById('generated-password');&#10;    const _pwgenResult = document.getElementById('pwgen-result');&#10;    const _pwStrength = document.getElementById('pw-strength');&#10;    const _pwStrengthLabel = document.getElementById('pw-strength-label');&#10;&#10;    const len = Math.max(4, Math.min(64, parseInt((_lengthEl &amp;&amp; _lengthEl.value) || 12) || 12));&#10;    const pw = generatePassword(&#10;        len,&#10;        (_useLower &amp;&amp; _useLower.dataset &amp;&amp; _useLower.dataset.checked === 'ON'),&#10;        (_useUpper &amp;&amp; _useUpper.dataset &amp;&amp; _useUpper.dataset.checked === 'ON'),&#10;        (_useNum &amp;&amp; _useNum.dataset &amp;&amp; _useNum.dataset.checked === 'ON'),&#10;        (_useSymbol &amp;&amp; _useSymbol.dataset &amp;&amp; _useSymbol.dataset.checked === 'ON')&#10;    );&#10;&#10;    // show result when at least one toggle is ON; deselection of any toggle will later hide via handlers&#10;    if (anyToggleOn()) {&#10;      if (_generatedPassword) {&#10;        _generatedPassword.value = pw;&#10;        _generatedPassword.type = pwVisible ? 'text' : 'password';&#10;      }&#10;      if (_pwgenResult) _pwgenResult.style.display = 'block';&#10;    } else {&#10;      resetPasswordDisplay();&#10;    }&#10;    const score = calcStrength(pw);&#10;    const info = strengthLabel(score);&#10;    if (_pwStrength) _pwStrength.style.width = (score * 20) + '%';&#10;    if (_pwStrengthLabel) _pwStrengthLabel.textContent = info.label;&#10;  }&#10;&#10;  // Initialize toggle visuals from DOM (if present)&#10;  toggleIds.forEach(id =&gt; {&#10;    const el = getToggleEl(id);&#10;    if (el) {&#10;      const init = el.dataset.checked === 'ON';&#10;      setToggleState(el, init);&#10;      console.log('pwgen.js: initialized toggle', id, '-&gt;', init);&#10;    }&#10;  });&#10;&#10;  // Delegated handler for toggles (covers dynamic/replaced elements)&#10;  // Use a short suppression window to so pointerdown+click don't double-toggle&#10;  const recentToggle = new Map();&#10;  const SUPPRESSION_MS = 300;&#10;&#10;  function handleDelegatedToggle(id) {&#10;    const now = Date.now();&#10;    const last = recentToggle.get(id) || 0;&#10;    if (now - last &lt; SUPPRESSION_MS) return; // skip duplicate&#10;    recentToggle.set(id, now);&#10;    const el = getToggleEl(id);&#10;    if (el) {&#10;      const current = el.dataset.checked === 'ON';&#10;      setToggleState(el, !current);&#10;      updateGenerateBtnState();&#10;      // if any toggle is OFF (i.e. not all ON), hide/reset the generated password&#10;      if (!allTogglesOn()) resetPasswordDisplay();&#10;    }&#10;    // clear after timeout to avoid memory leaks&#10;    setTimeout(() =&gt; recentToggle.delete(id), SUPPRESSION_MS + 50);&#10;  }&#10;&#10;  // Attach document-level delegated listeners only once&#10;  if (!window.__pwgen.listenersAttached) {&#10;    // delegated handler for generate button to ensure clicks are handled even if the button was replaced&#10;    document.addEventListener('click', function (e) {&#10;      const g = e.target.closest('#generate-btn');&#10;      if (!g) return;&#10;      e.preventDefault();&#10;      console.log('pwgen.js: delegated generate click');&#10;      try {&#10;        doGenerate();&#10;      } catch (err) {&#10;        console.error('doGenerate error', err);&#10;      }&#10;    });&#10;    // pointerdown delegated as fallback (some devices trigger pointer events instead)&#10;    document.addEventListener('pointerdown', function (e) {&#10;      const g = e.target.closest('#generate-btn');&#10;      if (!g) return;&#10;      e.preventDefault();&#10;      console.log('pwgen.js: delegated generate pointerdown');&#10;      try {&#10;        doGenerate();&#10;      } catch (err) {&#10;        console.error('doGenerate error', err);&#10;      }&#10;    });&#10;&#10;    document.addEventListener('pointerdown', function (e) {&#10;      const btn = e.target.closest('.opt-btn');&#10;      if (!btn) return;&#10;      const id = btn.id;&#10;      if (!toggleIds.includes(id)) return;&#10;      e.preventDefault();&#10;      console.log('pwgen.js: delegated pointerdown toggle for', id);&#10;      handleDelegatedToggle(id);&#10;    });&#10;&#10;    // click fallback for environments without pointer events&#10;    document.addEventListener('click', function (e) {&#10;      const btn = e.target.closest('.opt-btn');&#10;      if (!btn) return;&#10;      const id = btn.id;&#10;      if (!toggleIds.includes(id)) return;&#10;      console.log('pwgen.js: delegated click toggle for', id);&#10;      handleDelegatedToggle(id);&#10;    });&#10;&#10;    // keyboard shortcuts&#10;    document.addEventListener('keydown', (e) =&gt; {&#10;      if (e.altKey || e.ctrlKey || e.metaKey) return;&#10;      const active = document.activeElement;&#10;      if (active &amp;&amp; (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;&#10;      const map = {'1': 'use-lower', '2': 'use-upper', '3': 'use-num', '4': 'use-symbol'};&#10;      const id = map[e.key];&#10;      const target = id ? getToggleEl(id) : null;&#10;      if (target) {&#10;        e.preventDefault();&#10;        const newState = target.dataset.checked !== 'ON';&#10;        setToggleState(target, newState);&#10;        updateGenerateBtnState();&#10;        if (!allTogglesOn()) resetPasswordDisplay();&#10;        try {&#10;          target.focus();&#10;        } catch (_) {&#10;        }&#10;      }&#10;    });&#10;&#10;    window.__pwgen.listenersAttached = true;&#10;  }&#10;&#10;  // generate&#10;  if (generateBtn) {&#10;    try {&#10;      // avoid binding twice: mark element when bound&#10;      if (!generateBtn.dataset.pwgenBound) {&#10;        const newBtn = cloneReplace(generateBtn) || generateBtn;&#10;        newBtn.addEventListener('click', (e) =&gt; {&#10;          e.preventDefault();&#10;          console.log('pwgen.js: generate clicked');&#10;          doGenerate();&#10;        });&#10;        newBtn.dataset.pwgenBound = '1';&#10;        console.log('pwgen.js: attached generate handler');&#10;      }&#10;    } catch (_) {&#10;    }&#10;&#10;    // ensure generate button state reflects latest toggle states after cloning and binding&#10;    try {&#10;      updateGenerateBtnState();&#10;    } catch (_) {&#10;    }&#10;&#10;    // If any toggle is OFF on init, hide any previously generated result to avoid stale display&#10;    try {&#10;      if (!allTogglesOn()) resetPasswordDisplay();&#10;    } catch (_) {&#10;    }&#10;&#10;    // copy&#10;    if (copyBtn) {&#10;      try {&#10;        if (!copyBtn.dataset.pwgenBound) {&#10;          const newCopy = cloneReplace(copyBtn) || copyBtn;&#10;          newCopy.addEventListener('click', () =&gt; {&#10;            const val = (document.getElementById('generated-password') || {}).value || '';&#10;            if (!val) return;&#10;            console.log('pwgen.js: copy clicked');&#10;            navigator.clipboard.writeText(val).then(() =&gt; {&#10;              const tmp = document.createElement('div');&#10;              tmp.className = 'pw-toast';&#10;              tmp.textContent = 'コピーしました';&#10;              document.body.appendChild(tmp);&#10;              setTimeout(() =&gt; {&#10;                tmp.style.transition = 'opacity 0.3s';&#10;                tmp.style.opacity = '0';&#10;                setTimeout(() =&gt; tmp.remove(), 300);&#10;              }, 1000);&#10;            });&#10;          });&#10;          newCopy.dataset.pwgenBound = '1';&#10;          console.log('pwgen.js: attached copy handler');&#10;        }&#10;      } catch (_) {&#10;      }&#10;&#10;      // show/hide&#10;      if (showHideBtn) {&#10;        try {&#10;          if (!showHideBtn.dataset.pwgenBound) {&#10;            const newShow = cloneReplace(showHideBtn) || showHideBtn;&#10;            newShow.addEventListener('click', () =&gt; {&#10;              pwVisible = !pwVisible;&#10;              console.log('pwgen.js: showHide clicked -&gt;', pwVisible);&#10;              newShow.textContent = pwVisible ? '非表示' : '表示';&#10;              const gen = document.getElementById('generated-password');&#10;              if (gen) gen.type = pwVisible ? 'text' : 'password';&#10;            });&#10;            newShow.dataset.pwgenBound = '1';&#10;            console.log('pwgen.js: attached show/hide handler');&#10;          }&#10;        } catch (_) {&#10;        }&#10;      }&#10;&#10;      if (lengthEl) lengthEl.focus();&#10;    }&#10;&#10;    // keep DOMContentLoaded auto-init for first load&#10;    if (document.readyState === 'loading') {&#10;      document.addEventListener('DOMContentLoaded', function () {&#10;        initPwgen();&#10;      });&#10;    } else {&#10;      // already loaded - safe to init once&#10;      try {&#10;        initPwgen();&#10;      } catch (_) {&#10;      }&#10;    }&#10;&#10;    // Also ensure init runs on full window load as a fallback (covers edge cases of defer/order)&#10;    try {&#10;      window.addEventListener('load', function () {&#10;        try {&#10;          initPwgen();&#10;        } catch (_) {&#10;        }&#10;      });&#10;    } catch (_) {&#10;    }&#10;&#10;    // Extra short-delay fallback in case scripts are dynamically manipulated&#10;    setTimeout(function () {&#10;      try {&#10;        initPwgen();&#10;      } catch (_) {&#10;      }&#10;    }, 200);&#10;&#10;    // MutationObserver fallback: if relevant elements are inserted later (fragment/AJAX), ensure init runs&#10;    (function () {&#10;      try {&#10;        // attach only once globally to avoid creating many observers that each retrigger inits&#10;        if (window.__pwgen.observerAttached) return;&#10;        window.__pwgen.observerAttached = true;&#10;        const observedIds = new Set(['generate-btn', 'length', 'use-lower']);&#10;        const MIN_REINIT_MS = 300; // debounce re-inits&#10;        const obs = new MutationObserver((mutations) =&gt; {&#10;          try {&#10;            const now = Date.now();&#10;            if (typeof window.__pwgen.lastInit !== 'number') window.__pwgen.lastInit = 0;&#10;            if (now - window.__pwgen.lastInit &lt; MIN_REINIT_MS) return;&#10;            for (const m of mutations) {&#10;              if (m.addedNodes &amp;&amp; m.addedNodes.length) {&#10;                for (const node of m.addedNodes) {&#10;                  if (!(node instanceof Element)) continue;&#10;                  for (const id of observedIds) {&#10;                    if (node.id === id || (node.querySelector &amp;&amp; node.querySelector('#' + id))) {&#10;                      try {&#10;                        initPwgen();&#10;                        window.__pwgen.lastInit = Date.now();&#10;                      } catch (_) {&#10;                      }&#10;                      return;&#10;                    }&#10;                  }&#10;                }&#10;              }&#10;            }&#10;          } catch (_) {}&#10;        });&#10;        if (document &amp;&amp; document.body) obs.observe(document.body, {childList: true, subtree: true});&#10;        // Stop observing after some time to avoid long-running overhead but keep for a short window&#10;        setTimeout(() =&gt; {&#10;          try { obs.disconnect(); } catch (_) {}&#10;        }, 60000);&#10;      } catch (_) {}&#10;    })();&#10;&#10;    function generatePassword(length, useLower, useUpper, useNum, useSymbol) {&#10;      let chars = '';&#10;      if (useLower) chars += 'abcdefghijklmnopqrstuvwxyz';&#10;      if (useUpper) chars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';&#10;      if (useNum) chars += '0123456789';&#10;      if (useSymbol) chars += '!@#$%^&amp;*()';&#10;      if (!chars) return '';&#10;      let password = '';&#10;      for (let i = 0; i &lt; length; i++) {&#10;        password += chars.charAt(Math.floor(Math.random() * chars.length));&#10;      }&#10;      return password;&#10;    }&#10;&#10;    function calcStrength(pw) {&#10;      let score = 0;&#10;      if (pw.length &gt;= 8) score++;&#10;      if (/[a-z]/.test(pw)) score++;&#10;      if (/[A-Z]/.test(pw)) score++;&#10;      if (/[0-9]/.test(pw)) score++;&#10;      if (/[!@#$%^&amp;*()]/.test(pw)) score++;&#10;      return score;&#10;    }&#10;&#10;    function strengthLabel(score) {&#10;      switch (score) {&#10;        case 5:&#10;          return {label: '非常に強い'};&#10;        case 4:&#10;          return {label: '強い'};&#10;        case 3:&#10;          return {label: '普通'};&#10;        case 2:&#10;          return {label: '弱い'};&#10;        default:&#10;          return {label: 'とても弱い'};&#10;      }&#10;    }&#10;  }&#10;}" />
              <option name="updatedContent" value="// pwgen.js - externalized Vanilla JS for password generator&#10;// This file contains the optimized JS previously embedded in the dashboard fragment.&#10;&#10;// global guard to prevent duplicate attachment across multiple init calls&#10;if (!window.__pwgen) window.__pwgen = { listenersAttached: false };&#10;&#10;function initPwgen() {&#10;  console.log('pwgen.js: initPwgen start');&#10;  // prevent tight re-entry: ignore repeated inits within short window&#10;  try {&#10;    var now = Date.now();&#10;    // ensure shared lastInit exists&#10;    if (typeof window.__pwgen.lastInit !== 'number') window.__pwgen.lastInit = 0;&#10;    if (window.__pwgen.lastInit &amp;&amp; now - window.__pwgen.lastInit &lt; 250) {&#10;      console.log('pwgen.js: init suppressed (debounced)');&#10;      return;&#10;    }&#10;    window.__pwgen.lastInit = now;&#10;  } catch (_) {}&#10;&#10;  // element refs (use let so we can replace nodes safely)&#10;  let lengthEl = document.getElementById('length');&#10;  let lengthValueEl = document.getElementById('length-value');&#10;  let useLower = document.getElementById('use-lower');&#10;  let useUpper = document.getElementById('use-upper');&#10;  let useNum = document.getElementById('use-num');&#10;  let useSymbol = document.getElementById('use-symbol');&#10;  let generateBtn = document.getElementById('generate-btn');&#10;  let copyBtn = document.getElementById('copy-btn');&#10;  let showHideBtn = document.getElementById('show-hide-btn');&#10;&#10;  console.log('pwgen.js: elements', {&#10;    lengthEl: !!lengthEl,&#10;    useLower: !!useLower,&#10;    useUpper: !!useUpper,&#10;    useNum: !!useNum,&#10;    useSymbol: !!useSymbol,&#10;    generateBtn: !!generateBtn&#10;  });&#10;&#10;  let pwVisible = false;&#10;&#10;  // helper: toggle ids&#10;  const toggleIds = ['use-lower', 'use-upper', 'use-num', 'use-symbol'];&#10;&#10;  function getToggleEl(id) {&#10;    return document.getElementById(id);&#10;  }&#10;&#10;  // utility to replace an element with its clone to remove old listeners, returns new element&#10;  function cloneReplace(el) {&#10;    if (!el || !el.parentNode) return el;&#10;    try {&#10;      const newEl = el.cloneNode(true);&#10;      el.parentNode.replaceChild(newEl, el);&#10;      return newEl;&#10;    } catch (e) {&#10;      return el;&#10;    }&#10;  }&#10;&#10;  // length input&#10;  if (lengthEl &amp;&amp; lengthValueEl) {&#10;    // ensure previous listeners removed by cloning&#10;    lengthEl = cloneReplace(lengthEl);&#10;    lengthEl.addEventListener('input', () =&gt; {&#10;      lengthValueEl.textContent = lengthEl.value;&#10;    });&#10;  }&#10;&#10;  // wheel handling with minor throttle&#10;  let wheelQueued = false;&#10;  if (lengthEl) {&#10;    lengthEl.addEventListener('wheel', (e) =&gt; {&#10;      const ev = e;&#10;      const min = Number(lengthEl.min || 4);&#10;      const max = Number(lengthEl.max || 64);&#10;      const step = ev.shiftKey ? 5 : 1;&#10;      let val = Number(lengthEl.value);&#10;      if (ev.deltaY &lt; 0) val = Math.min(max, val + step);&#10;      else val = Math.max(min, val - step);&#10;      if (val !== Number(lengthEl.value)) {&#10;        e.preventDefault();&#10;        if (!wheelQueued) {&#10;          wheelQueued = true;&#10;          requestAnimationFrame(() =&gt; {&#10;            lengthEl.value = val;&#10;            lengthEl.dispatchEvent(new Event('input', {bubbles: true}));&#10;            wheelQueued = false;&#10;          });&#10;        }&#10;      }&#10;    }, {passive: false});&#10;  }&#10;&#10;  // toggle helpers&#10;  function setToggleState(el, on) {&#10;    if (!el) return;&#10;    el.setAttribute('aria-pressed', on ? 'true' : 'false');&#10;    el.dataset.checked = on ? 'ON' : 'OFF';&#10;    el.classList.toggle('opt-on', !!on);&#10;  }&#10;&#10;  function anyToggleOn() {&#10;    return toggleIds.some(id =&gt; {&#10;      const el = getToggleEl(id);&#10;      return el &amp;&amp; el.dataset &amp;&amp; el.dataset.checked === 'ON';&#10;    });&#10;  }&#10;&#10;  function allTogglesOn() {&#10;    return toggleIds.every(id =&gt; {&#10;      const el = getToggleEl(id);&#10;      return el &amp;&amp; el.dataset &amp;&amp; el.dataset.checked === 'ON';&#10;    });&#10;  }&#10;&#10;  function resetPasswordDisplay() {&#10;    // always read fresh elements to avoid stale references&#10;    try {&#10;      const _generatedPassword = document.getElementById('generated-password');&#10;      if (_generatedPassword) _generatedPassword.value = '';&#10;    } catch (_) {&#10;    }&#10;    try {&#10;      const _pwStrength = document.getElementById('pw-strength');&#10;      if (_pwStrength) _pwStrength.style.width = '0%';&#10;    } catch (_) {&#10;    }&#10;    try {&#10;      const _pwStrengthLabel = document.getElementById('pw-strength-label');&#10;      if (_pwStrengthLabel) _pwStrengthLabel.textContent = '';&#10;    } catch (_) {&#10;    }&#10;    try {&#10;      const _pwgenResult = document.getElementById('pwgen-result');&#10;      if (_pwgenResult) _pwgenResult.style.display = 'none';&#10;    } catch (_) {&#10;    }&#10;  }&#10;&#10;  function updateGenerateBtnState() {&#10;    try {&#10;      const btn = document.getElementById('generate-btn');&#10;      if (!btn) return;&#10;      btn.disabled = !anyToggleOn();&#10;    } catch (_) {&#10;    }&#10;  }&#10;&#10;  // generate logic (was missing after refactor)&#10;  function doGenerate() {&#10;    console.log('pwgen.js: doGenerate called, anyToggleOn=', anyToggleOn());&#10;    // query fresh elements to avoid stale references after fragment replacement&#10;    const _lengthEl = document.getElementById('length');&#10;    const _useLower = document.getElementById('use-lower');&#10;    const _useUpper = document.getElementById('use-upper');&#10;    const _useNum = document.getElementById('use-num');&#10;    const _useSymbol = document.getElementById('use-symbol');&#10;    const _generatedPassword = document.getElementById('generated-password');&#10;    const _pwgenResult = document.getElementById('pwgen-result');&#10;    const _pwStrength = document.getElementById('pw-strength');&#10;    const _pwStrengthLabel = document.getElementById('pw-strength-label');&#10;&#10;    const len = Math.max(4, Math.min(64, parseInt((_lengthEl &amp;&amp; _lengthEl.value) || 12) || 12));&#10;    const pw = generatePassword(&#10;        len,&#10;        (_useLower &amp;&amp; _useLower.dataset &amp;&amp; _useLower.dataset.checked === 'ON'),&#10;        (_useUpper &amp;&amp; _useUpper.dataset &amp;&amp; _useUpper.dataset.checked === 'ON'),&#10;        (_useNum &amp;&amp; _useNum.dataset &amp;&amp; _useNum.dataset.checked === 'ON'),&#10;        (_useSymbol &amp;&amp; _useSymbol.dataset &amp;&amp; _useSymbol.dataset.checked === 'ON')&#10;    );&#10;&#10;    // show result when at least one toggle is ON; deselection of any toggle will later hide via handlers&#10;    if (anyToggleOn()) {&#10;      if (_generatedPassword) {&#10;        _generatedPassword.value = pw;&#10;        _generatedPassword.type = pwVisible ? 'text' : 'password';&#10;      }&#10;      if (_pwgenResult) _pwgenResult.style.display = 'block';&#10;    } else {&#10;      resetPasswordDisplay();&#10;    }&#10;    const score = calcStrength(pw);&#10;    const info = strengthLabel(score);&#10;    if (_pwStrength) _pwStrength.style.width = (score * 20) + '%';&#10;    if (_pwStrengthLabel) _pwStrengthLabel.textContent = info.label;&#10;  }&#10;&#10;  // Initialize toggle visuals from DOM (if present)&#10;  toggleIds.forEach(id =&gt; {&#10;    const el = getToggleEl(id);&#10;    if (el) {&#10;      const init = el.dataset.checked === 'ON';&#10;      setToggleState(el, init);&#10;      console.log('pwgen.js: initialized toggle', id, '-&gt;', init);&#10;    }&#10;  });&#10;&#10;  // Delegated handler for toggles (covers dynamic/replaced elements)&#10;  // Use a short suppression window to so pointerdown+click don't double-toggle&#10;  const recentToggle = new Map();&#10;  const SUPPRESSION_MS = 300;&#10;&#10;  function handleDelegatedToggle(id) {&#10;    const now = Date.now();&#10;    const last = recentToggle.get(id) || 0;&#10;    if (now - last &lt; SUPPRESSION_MS) return; // skip duplicate&#10;    recentToggle.set(id, now);&#10;    const el = getToggleEl(id);&#10;    if (el) {&#10;      const current = el.dataset.checked === 'ON';&#10;      setToggleState(el, !current);&#10;      updateGenerateBtnState();&#10;      // if any toggle is OFF (i.e. not all ON), hide/reset the generated password&#10;      if (!allTogglesOn()) resetPasswordDisplay();&#10;    }&#10;    // clear after timeout to avoid memory leaks&#10;    setTimeout(() =&gt; recentToggle.delete(id), SUPPRESSION_MS + 50);&#10;  }&#10;&#10;  // Attach document-level delegated listeners only once&#10;  if (!window.__pwgen.listenersAttached) {&#10;    // delegated handler for generate button to ensure clicks are handled even if the button was replaced&#10;    document.addEventListener('click', function (e) {&#10;      const g = e.target.closest('#generate-btn');&#10;      if (!g) return;&#10;      e.preventDefault();&#10;      console.log('pwgen.js: delegated generate click');&#10;      try {&#10;        doGenerate();&#10;      } catch (err) {&#10;        console.error('doGenerate error', err);&#10;      }&#10;    });&#10;    // pointerdown delegated as fallback (some devices trigger pointer events instead)&#10;    document.addEventListener('pointerdown', function (e) {&#10;      const g = e.target.closest('#generate-btn');&#10;      if (!g) return;&#10;      e.preventDefault();&#10;      console.log('pwgen.js: delegated generate pointerdown');&#10;      try {&#10;        doGenerate();&#10;      } catch (err) {&#10;        console.error('doGenerate error', err);&#10;      }&#10;    });&#10;&#10;    document.addEventListener('pointerdown', function (e) {&#10;      const btn = e.target.closest('.opt-btn');&#10;      if (!btn) return;&#10;      const id = btn.id;&#10;      if (!toggleIds.includes(id)) return;&#10;      e.preventDefault();&#10;      console.log('pwgen.js: delegated pointerdown toggle for', id);&#10;      handleDelegatedToggle(id);&#10;    });&#10;&#10;    // click fallback for environments without pointer events&#10;    document.addEventListener('click', function (e) {&#10;      const btn = e.target.closest('.opt-btn');&#10;      if (!btn) return;&#10;      const id = btn.id;&#10;      if (!toggleIds.includes(id)) return;&#10;      console.log('pwgen.js: delegated click toggle for', id);&#10;      handleDelegatedToggle(id);&#10;    });&#10;&#10;    // keyboard shortcuts&#10;    document.addEventListener('keydown', (e) =&gt; {&#10;      if (e.altKey || e.ctrlKey || e.metaKey) return;&#10;      const active = document.activeElement;&#10;      if (active &amp;&amp; (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;&#10;      const map = {'1': 'use-lower', '2': 'use-upper', '3': 'use-num', '4': 'use-symbol'};&#10;      const id = map[e.key];&#10;      const target = id ? getToggleEl(id) : null;&#10;      if (target) {&#10;        e.preventDefault();&#10;        const newState = target.dataset.checked !== 'ON';&#10;        setToggleState(target, newState);&#10;        updateGenerateBtnState();&#10;        if (!allTogglesOn()) resetPasswordDisplay();&#10;        try {&#10;          target.focus();&#10;        } catch (_) {&#10;        }&#10;      }&#10;    });&#10;&#10;    window.__pwgen.listenersAttached = true;&#10;  }&#10;&#10;  // generate&#10;  if (generateBtn) {&#10;    try {&#10;      // avoid binding twice: mark element when bound&#10;      if (!generateBtn.dataset.pwgenBound) {&#10;        const newBtn = cloneReplace(generateBtn) || generateBtn;&#10;        newBtn.addEventListener('click', (e) =&gt; {&#10;          e.preventDefault();&#10;          console.log('pwgen.js: generate clicked');&#10;          doGenerate();&#10;        });&#10;        newBtn.dataset.pwgenBound = '1';&#10;        console.log('pwgen.js: attached generate handler');&#10;      }&#10;    } catch (_) {&#10;    }&#10;&#10;    // ensure generate button state reflects latest toggle states after cloning and binding&#10;    try {&#10;      updateGenerateBtnState();&#10;    } catch (_) {&#10;    }&#10;&#10;    // If any toggle is OFF on init, hide any previously generated result to avoid stale display&#10;    try {&#10;      if (!allTogglesOn()) resetPasswordDisplay();&#10;    } catch (_) {&#10;    }&#10;&#10;    // copy&#10;    if (copyBtn) {&#10;      try {&#10;        if (!copyBtn.dataset.pwgenBound) {&#10;          const newCopy = cloneReplace(copyBtn) || copyBtn;&#10;          newCopy.addEventListener('click', () =&gt; {&#10;            const val = (document.getElementById('generated-password') || {}).value || '';&#10;            if (!val) return;&#10;            console.log('pwgen.js: copy clicked');&#10;            navigator.clipboard.writeText(val).then(() =&gt; {&#10;              const tmp = document.createElement('div');&#10;              tmp.className = 'pw-toast';&#10;              tmp.textContent = 'コピーしました';&#10;              document.body.appendChild(tmp);&#10;              setTimeout(() =&gt; {&#10;                tmp.style.transition = 'opacity 0.3s';&#10;                tmp.style.opacity = '0';&#10;                setTimeout(() =&gt; tmp.remove(), 300);&#10;              }, 1000);&#10;            });&#10;          });&#10;          newCopy.dataset.pwgenBound = '1';&#10;          console.log('pwgen.js: attached copy handler');&#10;        }&#10;      } catch (_) {&#10;      }&#10;&#10;      // show/hide&#10;      if (showHideBtn) {&#10;        try {&#10;          if (!showHideBtn.dataset.pwgenBound) {&#10;            const newShow = cloneReplace(showHideBtn) || showHideBtn;&#10;            newShow.addEventListener('click', () =&gt; {&#10;              pwVisible = !pwVisible;&#10;              console.log('pwgen.js: showHide clicked -&gt;', pwVisible);&#10;              newShow.textContent = pwVisible ? '非表示' : '表示';&#10;              const gen = document.getElementById('generated-password');&#10;              if (gen) gen.type = pwVisible ? 'text' : 'password';&#10;            });&#10;            newShow.dataset.pwgenBound = '1';&#10;            console.log('pwgen.js: attached show/hide handler');&#10;          }&#10;        } catch (_) {&#10;        }&#10;      }&#10;&#10;      if (lengthEl) lengthEl.focus();&#10;    }&#10;&#10;    // keep DOMContentLoaded auto-init for first load&#10;    if (document.readyState === 'loading') {&#10;      document.addEventListener('DOMContentLoaded', function () {&#10;        initPwgen();&#10;      });&#10;    } else {&#10;      // already loaded - safe to init once&#10;      try {&#10;        initPwgen();&#10;      } catch (_) {&#10;      }&#10;    }&#10;&#10;    // Also ensure init runs on full window load as a fallback (covers edge cases of defer/order)&#10;    try {&#10;      window.addEventListener('load', function () {&#10;        try {&#10;          initPwgen();&#10;        } catch (_) {&#10;        }&#10;      });&#10;    } catch (_) {&#10;    }&#10;&#10;    // Extra short-delay fallback in case scripts are dynamically manipulated&#10;    setTimeout(function () {&#10;      try {&#10;        initPwgen();&#10;      } catch (_) {&#10;      }&#10;    }, 200);&#10;&#10;    // MutationObserver fallback: if relevant elements are inserted later (fragment/AJAX), ensure init runs&#10;    (function () {&#10;      try {&#10;        // attach only once globally to avoid creating many observers that each retrigger inits&#10;        if (window.__pwgen.observerAttached) return;&#10;        window.__pwgen.observerAttached = true;&#10;        const observedIds = new Set(['generate-btn', 'length', 'use-lower']);&#10;        const MIN_REINIT_MS = 300; // debounce re-inits&#10;        const obs = new MutationObserver((mutations) =&gt; {&#10;          try {&#10;            const now = Date.now();&#10;            if (typeof window.__pwgen.lastInit !== 'number') window.__pwgen.lastInit = 0;&#10;            if (now - window.__pwgen.lastInit &lt; MIN_REINIT_MS) return;&#10;            for (const m of mutations) {&#10;              if (m.addedNodes &amp;&amp; m.addedNodes.length) {&#10;                for (const node of m.addedNodes) {&#10;                  if (!(node instanceof Element)) continue;&#10;                  for (const id of observedIds) {&#10;                    if (node.id === id || (node.querySelector &amp;&amp; node.querySelector('#' + id))) {&#10;                      try {&#10;                        initPwgen();&#10;                        window.__pwgen.lastInit = Date.now();&#10;                      } catch (_) {&#10;                      }&#10;                      return;&#10;                    }&#10;                  }&#10;                }&#10;              }&#10;            }&#10;          } catch (_) {}&#10;        });&#10;        if (document &amp;&amp; document.body) obs.observe(document.body, {childList: true, subtree: true});&#10;        // Stop observing after some time to avoid long-running overhead but keep for a short window&#10;        setTimeout(() =&gt; {&#10;          try { obs.disconnect(); } catch (_) {}&#10;        }, 60000);&#10;      } catch (_) {}&#10;    })();&#10;&#10;    function generatePassword(length, useLower, useUpper, useNum, useSymbol) {&#10;      let chars = '';&#10;      if (useLower) chars += 'abcdefghijklmnopqrstuvwxyz';&#10;      if (useUpper) chars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';&#10;      if (useNum) chars += '0123456789';&#10;      if (useSymbol) chars += '!@#$%^&amp;*()';&#10;      if (!chars) return '';&#10;      let password = '';&#10;      for (let i = 0; i &lt; length; i++) {&#10;        password += chars.charAt(Math.floor(Math.random() * chars.length));&#10;      }&#10;      return password;&#10;    }&#10;&#10;    function calcStrength(pw) {&#10;      let score = 0;&#10;      if (pw.length &gt;= 8) score++;&#10;      if (/[a-z]/.test(pw)) score++;&#10;      if (/[A-Z]/.test(pw)) score++;&#10;      if (/[0-9]/.test(pw)) score++;&#10;      if (/[!@#$%^&amp;*()]/.test(pw)) score++;&#10;      return score;&#10;    }&#10;&#10;    function strengthLabel(score) {&#10;      switch (score) {&#10;        case 5:&#10;          return {label: '非常に強い'};&#10;        case 4:&#10;          return {label: '強い'};&#10;        case 3:&#10;          return {label: '普通'};&#10;        case 2:&#10;          return {label: '弱い'};&#10;        default:&#10;          return {label: 'とても弱い'};&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;// Fallback initializers: ensure initPwgen runs on full page refresh even when elements&#10;// are not yet present when the script executes (e.g. defer ordering, bfcache, etc.).&#10;// initPwgen is idempotent/debounced, so calling it multiple times is safe.&#10;(function () {&#10;  try {&#10;    // DOMContentLoaded / immediate run&#10;    if (document.readyState === 'loading') {&#10;      document.addEventListener('DOMContentLoaded', function () { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} });&#10;    } else {&#10;      try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;    }&#10;&#10;    // window load fallback&#10;    try { window.addEventListener('load', function () { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }); } catch (_) {}&#10;&#10;    // short timeout fallback&#10;    setTimeout(function () { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 250);&#10;&#10;    // lightweight MutationObserver fallback: if pwgen elements are inserted later, trigger init&#10;    if (!window.__pwgen || !window.__pwgen.fallbackObserverAttached) {&#10;      try {&#10;        window.__pwgen = window.__pwgen || {};&#10;        window.__pwgen.fallbackObserverAttached = true;&#10;        const obs = new MutationObserver((mutations) =&gt; {&#10;          try {&#10;            for (const m of mutations) {&#10;              if (m.addedNodes &amp;&amp; m.addedNodes.length) {&#10;                for (const node of m.addedNodes) {&#10;                  if (!(node instanceof Element)) continue;&#10;                  if (node.id === 'generate-btn' || node.querySelector &amp;&amp; node.querySelector('#generate-btn')) {&#10;                    try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                    obs.disconnect();&#10;                    return;&#10;                  }&#10;                }&#10;              }&#10;            }&#10;          } catch (_) {}&#10;        });&#10;        if (document &amp;&amp; document.body) obs.observe(document.body, { childList: true, subtree: true });&#10;        // disconnect after short window to avoid long-lived observers&#10;        setTimeout(() =&gt; { try { obs.disconnect(); } catch (_) {} }, 60000);&#10;      } catch (_) {}&#10;    }&#10;  } catch (_) {}&#10;})();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>