<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt" />
              <option name="originalContent" value="package com.example.demo.config&#10;&#10;import io.undertow.server.DefaultByteBufferPool&#10;import io.undertow.websockets.jsr.WebSocketDeploymentInfo&#10;import org.springframework.boot.web.embedded.undertow.UndertowDeploymentInfoCustomizer&#10;import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory&#10;import org.springframework.context.annotation.Bean&#10;import org.springframework.context.annotation.Configuration&#10;import org.springframework.core.env.Environment&#10;import org.springframework.util.unit.DataSize&#10;&#10;@Configuration&#10;class UndertowWebSocketConfig(&#10;    private val env: Environment&#10;) {&#10;&#10;    @Bean&#10;    fun undertowServletWebServerFactory(): UndertowServletWebServerFactory {&#10;        val factory = UndertowServletWebServerFactory()&#10;&#10;        val customizer = UndertowDeploymentInfoCustomizer { di -&gt;&#10;            // Undertow の WebSocket 用バッファプールを設定（警告 UT026010 の解消）&#10;            val direct = true // 直接バッファ（GC 負荷軽減）&#10;            val dataSize: DataSize = env.getProperty(&#10;                &quot;server.undertow.buffer-size&quot;,&#10;                DataSize::class.java,&#10;                DataSize.ofKilobytes(16)&#10;            )&#10;            val bufferSize: Int = dataSize.toBytes().coerceAtMost(Int.MAX_VALUE.toLong()).toInt()&#10;            val wsInfo = WebSocketDeploymentInfo()&#10;            wsInfo.buffers = DefaultByteBufferPool(direct, bufferSize)&#10;            (di as io.undertow.servlet.api.DeploymentInfo)&#10;                .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, wsInfo)&#10;        }&#10;&#10;        factory.setDeploymentInfoCustomizers(listOf(customizer))&#10;        return factory&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo.config&#13;&#10;&#13;&#10;import org.springframework.context.annotation.Configuration&#13;&#10;&#13;&#10;@Configuration&#13;&#10;class UndertowWebSocketConfig {&#13;&#10;    // Undertow を削除したため本クラスは空のプレースホルダです。&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/static/js/manage.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/static/js/manage.js" />
              <option name="originalContent" value="// 管理画面用クライアントスクリプト（manage.js）&#10;// - 役割: コンテンツ項目とメニューの一覧取得、追加・編集・削除を行う&#10;// - 非同期通信は fetch を使用し、簡易なプロンプトUIで動作します&#10;// - エラー時はユーザーへ alert を表示してフォールバックします&#10;&#10;// Simple manage.js: fetch list of content items and provide add/edit/delete using prompt dialogs&#10;(function () {&#10;  'use strict';&#10;&#10;  // API エンドポイントの定義&#10;  const apiContent = '/api/content';&#10;  const apiMenus = '/api/menus';&#10;&#10;  // DOM ヘルパ関数&#10;  function qs(sel) { return document.querySelector(sel); }&#10;  function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }&#10;&#10;  // キャッシュ: メニュー一覧を保持して選択肢を高速に構築&#10;  let menusCache = [];&#10;&#10;  // BroadcastChannel を使って同一ブラウザ内のタブ間で更新を通知する&#10;  const menusBroadcast = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('menus-channel') : null;&#10;&#10;  // --- レンダリング用関数 ---&#10;  // テーブル行を作成するユーティリティ&#10;  function renderMenuRow(menu) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = menu.id || '';&#10;    const nameTd = document.createElement('td'); nameTd.textContent = menu.name || '';&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditMenu(menu));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteMenu(menu));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // セレクト要素を作成して現在値を反映する&#10;  function buildMenuSelect(currentValue, item) {&#10;    const select = document.createElement('select');&#10;    select.className = 'form-select form-select-sm menu-select';&#10;    // for debugging/tracking&#10;    if (item &amp;&amp; item.id) select.setAttribute('data-item-id', item.id);&#10;&#10;    // ensure currentValue is represented even if it's not in menusCache&#10;    const hasCurrent = menusCache.some(m =&gt; m.name === currentValue);&#10;&#10;    // empty option&#10;    const emptyOpt = document.createElement('option');&#10;    emptyOpt.value = '';&#10;    emptyOpt.textContent = '未選択';&#10;    select.appendChild(emptyOpt);&#10;&#10;    // add known menus&#10;    menusCache.forEach(m =&gt; {&#10;      const opt = document.createElement('option');&#10;      opt.value = m.name;&#10;      opt.textContent = m.name;&#10;      select.appendChild(opt);&#10;    });&#10;&#10;    // if current value missing from menusCache, add it so the select shows it&#10;    if (currentValue &amp;&amp; !hasCurrent) {&#10;      const opt = document.createElement('option');&#10;      opt.value = currentValue;&#10;      opt.textContent = currentValue + ' (削除済み)';&#10;      // insert after empty option&#10;      select.insertBefore(opt, select.children[1] || null);&#10;    }&#10;&#10;    select.value = currentValue || '';&#10;&#10;    // handle change&#10;    select.addEventListener('change', async function (ev) {&#10;      const newVal = ev.target.value || null;&#10;      await onChangeMenuForItem(item, newVal, ev.target);&#10;    });&#10;&#10;    return select;&#10;  }&#10;&#10;  // 画面項目の行レンダリング&#10;  function renderScreenRow(item) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = item.id || '';&#10;    const menuTd = document.createElement('td');&#10;    const nameTd = document.createElement('td'); nameTd.textContent = item.itemName || '';&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditScreen(item));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteScreen(item));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    // create select for menu name&#10;    const select = buildMenuSelect(item.menuName, item);&#10;    menuTd.appendChild(select);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(menuTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // --- ヘルパ ---&#10;  // メニューキャッシュが更新された際に、既存のセレクト要素を再構築する&#10;  function refreshMenuSelects() {&#10;    const selects = qsa('.menu-select');&#10;    selects.forEach(sel =&gt; {&#10;      const currentVal = sel.value || '';&#10;      // try to preserve selection&#10;      // rebuild options&#10;      while (sel.firstChild) sel.removeChild(sel.firstChild);&#10;&#10;      const emptyOpt = document.createElement('option');&#10;      emptyOpt.value = '';&#10;      emptyOpt.textContent = '未選択';&#10;      sel.appendChild(emptyOpt);&#10;      menusCache.forEach(m =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = m.name;&#10;        opt.textContent = m.name;&#10;        sel.appendChild(opt);&#10;      });&#10;      if (currentVal &amp;&amp; !menusCache.some(m =&gt; m.name === currentVal)) {&#10;        const opt = document.createElement('option');&#10;        opt.value = currentVal;&#10;        opt.textContent = currentVal + ' (削除済み)';&#10;        sel.insertBefore(opt, sel.children[1] || null);&#10;      }&#10;      sel.value = currentVal;&#10;    });&#10;  }&#10;&#10;  // 内容のメニュー変更をサーバへ送信するハンドラ&#10;  async function onChangeMenuForItem(item, newMenuName, selectElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.menuName || null;&#10;    if (newMenuName === prev) return; // nothing to do&#10;&#10;    const payload = Object.assign({}, item, { menuName: newMenuName });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        // サーバエラー: ユーザーへ通知して選択を元に戻す&#10;        alert('メニューの更新に失敗しました');&#10;        try { selectElem.value = prev || ''; } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.menuName = newMenuName;&#10;      // optional: show tiny feedback (could be improved)&#10;      // e.g., briefly flash background&#10;      selectElem.classList.add('is-valid');&#10;      setTimeout(() =&gt; selectElem.classList.remove('is-valid'), 800);&#10;    } catch (e) {&#10;      alert('メニューの更新に失敗しました');&#10;      // revert selection&#10;      try { selectElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // --- データロード ---&#10;  // メニュー一覧を読み込みテーブルを更新&#10;  async function loadMenus() {&#10;    const tbody = qs('#menuTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      const resp = await fetch(apiMenus + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const menus = await resp.json();&#10;      menusCache = menus || [];&#10;      tbody.innerHTML = '';&#10;      if (!menusCache || !menusCache.length) {&#10;        // If there are no menus defined in menu management, try to show menuNames derived from screens&#10;        // This avoids confusing mismatch where home shows menus (from screens) but admin shows none.&#10;        // Load screens and extract unique menuName values.&#10;        try {&#10;          const r = await fetch(apiContent + '/all');&#10;          if (!r.ok) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          const items = await r.json();&#10;          const menuNames = Array.from(new Set((items || []).map(it =&gt; it.menuName).filter(Boolean)));&#10;          if (!menuNames.length) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          // Render derived menu rows with a note and an import button&#10;          menuNames.forEach((name, idx) =&gt; {&#10;            const tr = document.createElement('tr');&#10;            const idTd = document.createElement('td'); idTd.textContent = '';&#10;            const nameTd = document.createElement('td'); nameTd.textContent = name + ' (画面管理由来)';&#10;            const actionsTd = document.createElement('td');&#10;&#10;            const importBtn = document.createElement('button');&#10;            importBtn.className = 'btn btn-sm btn-outline-success me-2';&#10;            importBtn.textContent = 'インポート';&#10;            importBtn.addEventListener('click', async () =&gt; {&#10;              // create menu via API&#10;              try {&#10;                const resp2 = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });&#10;                if (!resp2.ok) {&#10;                  alert('インポートに失敗しました');&#10;                  return;&#10;                }&#10;                // reload official menus&#10;                await loadMenus();&#10;                await loadScreens();&#10;              } catch (e) {&#10;                alert('インポートに失敗しました');&#10;              }&#10;            });&#10;&#10;            actionsTd.appendChild(importBtn);&#10;            tr.appendChild(idTd);&#10;            tr.appendChild(nameTd);&#10;            tr.appendChild(actionsTd);&#10;            tbody.appendChild(tr);&#10;          });&#10;          // ensure selects are refreshed&#10;          refreshMenuSelects();&#10;          return menuNames;&#10;        } catch (e) {&#10;          tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;          // still refresh selects to show empty options&#10;          refreshMenuSelects();&#10;          return [];&#10;        }&#10;      }&#10;      menusCache.forEach(m =&gt; tbody.appendChild(renderMenuRow(m)));&#10;      // update any existing select elements in screens&#10;      refreshMenuSelects();&#10;      return menusCache;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // 画面項目一覧を読み込みテーブルを更新&#10;  async function loadScreens() {&#10;    const tbody = qs('#manageTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      // ensure menusCache is populated so selects can be built properly&#10;      if (!menusCache || !menusCache.length) {&#10;        await loadMenus();&#10;      }&#10;      const resp = await fetch(apiContent + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const items = await resp.json();&#10;      tbody.innerHTML = '';&#10;      if (!items || !items.length) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;項目がありません&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      items.forEach(it =&gt; tbody.appendChild(renderScreenRow(it)));&#10;      return items;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // --- メニュー操作 ---&#10;  // 追加・編集・削除の各操作（ユーザー確認/プロンプトを含む）&#10;  async function onAddMenu() {&#10;    const name = window.prompt('追加するメニュー名を入力してください', '新しいメニュー');&#10;    if (!name) return;&#10;    const payload = { name };&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('メニュー作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      // refresh menu dropdowns for adding screens&#10;      await loadScreens();&#10;      // notify other tabs/pages to refresh sidebar menus&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('メニュー作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditMenu(menu) {&#10;    const name = window.prompt('メニュー名を編集してください', menu.name || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, menu, { name });&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteMenu(menu) {&#10;    if (!window.confirm('このメニューを削除してよいですか?（メニューに紐づく画面がある場合、連鎖的な整合性は考慮していません）')) return;&#10;    try {&#10;      const resp = await fetch(apiMenus + '/' + menu.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // --- 画面項目操作 ---&#10;  async function onAddScreen() {&#10;    const name = window.prompt('追加する画面名を入力してください', '新しい画面');&#10;    if (!name) return;&#10;    // choose menu from existing&#10;    const menus = await loadMenus();&#10;    if (!menus || !menus.length) {&#10;      alert('先にメニューを追加してください');&#10;      return;&#10;    }&#10;    // build selection prompt&#10;    let list = 'メニューを選んで番号を入力してください:\n';&#10;    menus.forEach((m, idx) =&gt; { list += `${idx + 1}: ${m.name}\n`; });&#10;    const sel = window.prompt(list, '1');&#10;    if (!sel) return;&#10;    const idx = parseInt(sel) - 1;&#10;    if (isNaN(idx) || idx &lt; 0 || idx &gt;= menus.length) { alert('不正な選択'); return; }&#10;    const menuName = menus[idx].name;&#10;    const payload = { itemName: name, menuName };&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditScreen(item) {&#10;    // Per requirement, menuName is editable via select — here only itemName editable&#10;    const name = window.prompt('画面名を編集してください', item.itemName || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, item, { itemName: name });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteScreen(item) {&#10;    if (!window.confirm('削除してよいですか?')) return;&#10;    try {&#10;      const resp = await fetch(apiContent + '/' + item.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // 初期化: DOMContentLoaded 時にイベントリスナを登録しデータをロード&#10;  document.addEventListener('DOMContentLoaded', function () {&#10;    const addMenuBtn = qs('#addMenuBtn');&#10;    if (addMenuBtn) addMenuBtn.addEventListener('click', onAddMenu);&#10;    const addScreenBtn = qs('#addScreenBtn');&#10;    if (addScreenBtn) addScreenBtn.addEventListener('click', onAddScreen);&#10;    // 初回ロードでメニュー→画面の順で読み込み&#10;    loadMenus().then(() =&gt; loadScreens());&#10;  });&#10;&#10;})();&#10;" />
              <option name="updatedContent" value="// 管理画面用クライアントスクリプト（manage.js）&#10;// - 役割: コンテンツ項目とメニューの一覧取得、追加・編集・削除を行う&#10;// - 非同期通信は fetch を使用し、簡易なプロンプトUIで動作します&#10;// - エラー時はユーザーへ alert を表示してフォールバックします&#10;&#10;// Simple manage.js: fetch list of content items and provide add/edit/delete using prompt dialogs&#10;(function () {&#10;  'use strict';&#10;&#10;  // API エンドポイントの定義&#10;  const apiContent = '/api/content';&#10;  const apiMenus = '/api/menus';&#10;&#10;  // DOM ヘルパ関数&#10;  function qs(sel) { return document.querySelector(sel); }&#10;  function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }&#10;&#10;  // キャッシュ: メニュー一覧を保持して選択肢を高速に構築&#10;  let menusCache = [];&#10;&#10;  // BroadcastChannel を使って同一ブラウザ内のタブ間で更新を通知する&#10;  const menusBroadcast = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('menus-channel') : null;&#10;&#10;  // --- レンダリング用関数 ---&#10;  // テーブル行を作成するユーティリティ&#10;  function renderMenuRow(menu) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = menu.id || '';&#10;    const nameTd = document.createElement('td'); nameTd.textContent = menu.name || '';&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditMenu(menu));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteMenu(menu));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // セレクト要素を作成して現在値を反映する&#10;  function buildMenuSelect(currentValue, item) {&#10;    const select = document.createElement('select');&#10;    select.className = 'form-select form-select-sm menu-select';&#10;    // for debugging/tracking&#10;    if (item &amp;&amp; item.id) select.setAttribute('data-item-id', item.id);&#10;&#10;    // ensure currentValue is represented even if it's not in menusCache&#10;    const hasCurrent = menusCache.some(m =&gt; m.name === currentValue);&#10;&#10;    // empty option&#10;    const emptyOpt = document.createElement('option');&#10;    emptyOpt.value = '';&#10;    emptyOpt.textContent = '未選択';&#10;    select.appendChild(emptyOpt);&#10;&#10;    // add known menus&#10;    menusCache.forEach(m =&gt; {&#10;      const opt = document.createElement('option');&#10;      opt.value = m.name;&#10;      opt.textContent = m.name;&#10;      select.appendChild(opt);&#10;    });&#10;&#10;    // if current value missing from menusCache, add it so the select shows it&#10;    if (currentValue &amp;&amp; !hasCurrent) {&#10;      const opt = document.createElement('option');&#10;      opt.value = currentValue;&#10;      opt.textContent = currentValue + ' (削除済み)';&#10;      // insert after empty option&#10;      select.insertBefore(opt, select.children[1] || null);&#10;    }&#10;&#10;    select.value = currentValue || '';&#10;&#10;    // handle change&#10;    select.addEventListener('change', async function (ev) {&#10;      const newVal = ev.target.value || null;&#10;      await onChangeMenuForItem(item, newVal, ev.target);&#10;    });&#10;&#10;    return select;&#10;  }&#10;&#10;  // 画面項目の行レンダリング&#10;  function renderScreenRow(item) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = item.id || '';&#10;    const menuTd = document.createElement('td');&#10;    const nameTd = document.createElement('td'); nameTd.textContent = item.itemName || '';&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditScreen(item));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteScreen(item));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    // create select for menu name&#10;    const select = buildMenuSelect(item.menuName, item);&#10;    menuTd.appendChild(select);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(menuTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // --- ヘルパ ---&#10;  // メニューキャッシュが更新された際に、既存のセレクト要素を再構築する&#10;  function refreshMenuSelects() {&#10;    const selects = qsa('.menu-select');&#10;    selects.forEach(sel =&gt; {&#10;      const currentVal = sel.value || '';&#10;      // try to preserve selection&#10;      // rebuild options&#10;      while (sel.firstChild) sel.removeChild(sel.firstChild);&#10;&#10;      const emptyOpt = document.createElement('option');&#10;      emptyOpt.value = '';&#10;      emptyOpt.textContent = '未選択';&#10;      sel.appendChild(emptyOpt);&#10;      menusCache.forEach(m =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = m.name;&#10;        opt.textContent = m.name;&#10;        sel.appendChild(opt);&#10;      });&#10;      if (currentVal &amp;&amp; !menusCache.some(m =&gt; m.name === currentVal)) {&#10;        const opt = document.createElement('option');&#10;        opt.value = currentVal;&#10;        opt.textContent = currentVal + ' (削除済み)';&#10;        sel.insertBefore(opt, sel.children[1] || null);&#10;      }&#10;      sel.value = currentVal;&#10;    });&#10;  }&#10;&#10;  // 内容のメニュー変更をサーバへ送信するハンドラ&#10;  async function onChangeMenuForItem(item, newMenuName, selectElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.menuName || null;&#10;    if (newMenuName === prev) return; // nothing to do&#10;&#10;    const payload = Object.assign({}, item, { menuName: newMenuName });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        // サーバエラー: ユーザーへ通知して選択を元に戻す&#10;        alert('メニューの更新に失敗しました');&#10;        try { selectElem.value = prev || ''; } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.menuName = newMenuName;&#10;      // optional: show tiny feedback (could be improved)&#10;      // e.g., briefly flash background&#10;      selectElem.classList.add('is-valid');&#10;      setTimeout(() =&gt; selectElem.classList.remove('is-valid'), 800);&#10;    } catch (e) {&#10;      alert('メニューの更新に失敗しました');&#10;      // revert selection&#10;      try { selectElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // --- データロード ---&#10;  // メニュー一覧を読み込みテーブルを更新&#10;  async function loadMenus() {&#10;    const tbody = qs('#menuTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      const resp = await fetch(apiMenus + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const menus = await resp.json();&#10;      menusCache = menus || [];&#10;      tbody.innerHTML = '';&#10;      if (!menusCache || !menusCache.length) {&#10;        // If there are no menus defined in menu management, try to show menuNames derived from screens&#10;        // This avoids confusing mismatch where home shows menus (from screens) but admin shows none.&#10;        // Load screens and extract unique menuName values.&#10;        try {&#10;          const r = await fetch(apiContent + '/all');&#10;          if (!r.ok) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          const items = await r.json();&#10;          const menuNames = Array.from(new Set((items || []).map(it =&gt; it.menuName).filter(Boolean)));&#10;          if (!menuNames.length) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          // Render derived menu rows with a note and an import button&#10;          menuNames.forEach((name) =&gt; {&#10;            const tr = document.createElement('tr');&#10;            const idTd = document.createElement('td'); idTd.textContent = '';&#10;            const nameTd = document.createElement('td'); nameTd.textContent = name + ' (画面管理由来)';&#10;            const actionsTd = document.createElement('td');&#10;&#10;            const importBtn = document.createElement('button');&#10;            importBtn.className = 'btn btn-sm btn-outline-success me-2';&#10;            importBtn.textContent = 'インポート';&#10;            importBtn.addEventListener('click', async () =&gt; {&#10;              // create menu via API&#10;              try {&#10;                const resp2 = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });&#10;                if (!resp2.ok) {&#10;                  alert('インポートに失敗しました');&#10;                  return;&#10;                }&#10;                // reload official menus&#10;                await loadMenus();&#10;                await loadScreens();&#10;              } catch (e) {&#10;                alert('インポートに失敗しました');&#10;              }&#10;            });&#10;&#10;            actionsTd.appendChild(importBtn);&#10;            tr.appendChild(idTd);&#10;            tr.appendChild(nameTd);&#10;            tr.appendChild(actionsTd);&#10;            tbody.appendChild(tr);&#10;          });&#10;          // ensure selects are refreshed&#10;          refreshMenuSelects();&#10;          return menuNames;&#10;        } catch (e) {&#10;          tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;          // still refresh selects to show empty options&#10;          refreshMenuSelects();&#10;          return [];&#10;        }&#10;      }&#10;      menusCache.forEach(m =&gt; tbody.appendChild(renderMenuRow(m)));&#10;      // update any existing select elements in screens&#10;      refreshMenuSelects();&#10;      return menusCache;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // 画面項目一覧を読み込みテーブルを更新&#10;  async function loadScreens() {&#10;    const tbody = qs('#manageTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      // ensure menusCache is populated so selects can be built properly&#10;      if (!menusCache || !menusCache.length) {&#10;        await loadMenus();&#10;      }&#10;      const resp = await fetch(apiContent + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const items = await resp.json();&#10;      tbody.innerHTML = '';&#10;      if (!items || !items.length) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;項目がありません&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      items.forEach(it =&gt; tbody.appendChild(renderScreenRow(it)));&#10;      return items;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // --- メニュー操作 ---&#10;  // 追加・編集・削除の各操作（ユーザー確認/プロンプトを含む）&#10;  async function onAddMenu() {&#10;    const name = window.prompt('追加するメニュー名を入力してください', '新しいメニュー');&#10;    if (!name) return;&#10;    const payload = { name };&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('メニュー作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      // refresh menu dropdowns for adding screens&#10;      await loadScreens();&#10;      // notify other tabs/pages to refresh sidebar menus&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('メニュー作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditMenu(menu) {&#10;    const name = window.prompt('メニュー名を編集してください', menu.name || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, menu, { name });&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteMenu(menu) {&#10;    if (!window.confirm('このメニューを削除してよいですか?（メニューに紐づく画面がある場合、連鎖的な整合性は考慮していません）')) return;&#10;    try {&#10;      const resp = await fetch(apiMenus + '/' + menu.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // --- 画面項目操作 ---&#10;  async function onAddScreen() {&#10;    const name = window.prompt('追加する画面名を入力してください', '新しい画面');&#10;    if (!name) return;&#10;    // choose menu from existing&#10;    const menus = await loadMenus();&#10;    if (!menus || !menus.length) {&#10;      alert('先にメニューを追加してください');&#10;      return;&#10;    }&#10;    // build selection prompt&#10;    let list = 'メニューを選んで番号を入力してください:\n';&#10;    menus.forEach((m, idx) =&gt; { list += `${idx + 1}: ${m.name}\n`; });&#10;    const sel = window.prompt(list, '1');&#10;    if (!sel) return;&#10;    const idx = parseInt(sel) - 1;&#10;    if (isNaN(idx) || idx &lt; 0 || idx &gt;= menus.length) { alert('不正な選択'); return; }&#10;    const menuName = menus[idx].name;&#10;    const payload = { itemName: name, menuName };&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditScreen(item) {&#10;    // Per requirement, menuName is editable via select — here only itemName editable&#10;    const name = window.prompt('画面名を編集してください', item.itemName || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, item, { itemName: name });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteScreen(item) {&#10;    if (!window.confirm('削除してよいですか?')) return;&#10;    try {&#10;      const resp = await fetch(apiContent + '/' + item.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // 初期化: DOMContentLoaded 時にイベントリスナを登録しデータをロード&#10;  document.addEventListener('DOMContentLoaded', function () {&#10;    const addMenuBtn = qs('#addMenuBtn');&#10;    if (addMenuBtn) addMenuBtn.addEventListener('click', onAddMenu);&#10;    const addScreenBtn = qs('#addScreenBtn');&#10;    if (addScreenBtn) addScreenBtn.addEventListener('click', onAddScreen);&#10;    // 初回ロードでメニュー→画面の順で読み込み&#10;    loadMenus().then(() =&gt; loadScreens());&#10;  });&#10;&#10;})();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>