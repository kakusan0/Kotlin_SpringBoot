<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/MainController.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/MainController.kt" />
              <option name="originalContent" value="package com.example.demo&#10;&#10;import com.example.demo.constants.ApplicationConstants&#10;import com.example.demo.service.ContentItemService&#10;import com.example.demo.service.MenuService&#10;import org.springframework.core.io.ClassPathResource&#10;import org.springframework.stereotype.Controller&#10;import org.springframework.ui.Model&#10;import org.springframework.web.bind.annotation.GetMapping&#10;import org.springframework.web.bind.annotation.RequestParam&#10;import org.springframework.validation.annotation.Validated&#10;import jakarta.validation.constraints.Size&#10;&#10;@Controller&#10;@Validated&#10;class MainController(&#10;    private val contentItemService: ContentItemService,&#10;    private val menuService: MenuService&#10;) {&#10;    // 共通のモデル属性をセットするヘルパ&#10;    private fun addCommonAttributes(model: Model) {&#10;        val screens = contentItemService.getAll()&#10;        model.addAttribute(&quot;screens&quot;, screens)&#10;        val menus = menuService.getAll()&#10;        model.addAttribute(&quot;menus&quot;, menus)&#10;        // visibleMenus: Home 画面などで表示するメニューは、画面管理で割り当てられている menuName のみ&#10;        val assignedMenuNames = screens.mapNotNull { it.menuName }.map { it.trim() }.filter { it.isNotEmpty() }.toSet()&#10;        val visibleMenus = if (assignedMenuNames.isEmpty()) {&#10;            // none assigned -&gt; empty list (do not show menus on Home)&#10;            emptyList&lt;com.example.demo.model.Menu&gt;()&#10;        } else {&#10;            menus.filter { it.name != null &amp;&amp; assignedMenuNames.contains(it.name!!.trim()) }&#10;        }&#10;        model.addAttribute(&quot;visibleMenus&quot;, visibleMenus)&#10;    }&#10;&#10;    @GetMapping(ApplicationConstants.ROOT)&#10;    fun root(model: Model): String {&#10;        addCommonAttributes(model)&#10;        // ensure template has these attributes to avoid Thymeleaf evaluating a null fragment name&#10;        model.addAttribute(&quot;currentScreen&quot;, &quot;&quot;)&#10;        model.addAttribute(&quot;selectedScreenName&quot;, &quot;メニューを選択&quot;)&#10;        model.addAttribute(&quot;currentScreenPath&quot;, &quot;&quot;)&#10;        return &quot;main&quot;&#10;    }&#10;&#10;    @GetMapping(ApplicationConstants.CONTENT)&#10;    fun selectItem(&#10;        @RequestParam(name = &quot;screenName&quot;, defaultValue = &quot;未選択&quot;) @Size(max = 255, message = &quot;screenName: 255文字以内で入力してください&quot;) screenName: String,&#10;        model: Model&#10;    ): String {&#10;        model.addAttribute(&quot;errorMessage&quot;, null)&#10;        addCommonAttributes(model)&#10;&#10;        // currentScreen は未選択なら空文字、それ以外はクエリ値をそのまま使う&#10;        val current = if (screenName == &quot;未選択&quot;) &quot;&quot; else screenName&#10;        model.addAttribute(&quot;currentScreen&quot;, current)&#10;&#10;        // selectedScreenName は未選択のときはプレースホルダ。screenName が与えられていればそれを優先して表示。&#10;        val selected = if (screenName == &quot;未選択&quot;) &quot;メニューを選択&quot; else screenName&#10;        model.addAttribute(&quot;selectedScreenName&quot;, selected)&#10;&#10;        // 追加: 選択された画面名に対応する ContentItem を探して pathName を currentScreenPath としてモデルにセット&#10;        val currentPath = if (screenName == &quot;未選択&quot;) {&#10;            &quot;&quot;&#10;        } else {&#10;            val found = contentItemService.getAll().firstOrNull { it.itemName == screenName }&#10;            if (found == null) {&#10;                &quot;&quot;&#10;            } else {&#10;                val pn = found.pathName&#10;                // defensive: treat literal &quot;null&quot; (from bad DB values) as missing&#10;                val normalizedPn = pn?.trim()?.takeIf { it.isNotEmpty() &amp;&amp; !it.equals(&quot;null&quot;, ignoreCase = true) }&#10;                if (normalizedPn.isNullOrBlank()) {&#10;                    &quot;&quot;&#10;                } else {&#10;                    val candidate = normalizedPn&#10;                    val resourcePath = &quot;templates/fragments/${candidate}.html&quot;&#10;                    val res = ClassPathResource(resourcePath)&#10;                    if (res.exists()) candidate else {&#10;                        model.addAttribute(&quot;errorMessage&quot;, &quot;指定された画面（${candidate}）のテンプレートが見つかりません。&quot;)&#10;                        &quot;&quot;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        model.addAttribute(&quot;currentScreenPath&quot;, currentPath)&#10;&#10;        return &quot;main&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo&#10;&#10;import com.example.demo.constants.ApplicationConstants&#10;import com.example.demo.service.ContentItemService&#10;import com.example.demo.service.MenuService&#10;import org.springframework.core.io.ClassPathResource&#10;import org.springframework.stereotype.Controller&#10;import org.springframework.ui.Model&#10;import org.springframework.web.bind.annotation.GetMapping&#10;import org.springframework.web.bind.annotation.RequestParam&#10;import org.springframework.validation.annotation.Validated&#10;import jakarta.validation.constraints.Size&#10;&#10;@Controller&#10;@Validated&#10;class MainController(&#10;    private val contentItemService: ContentItemService,&#10;    private val menuService: MenuService&#10;) {&#10;    // 共通のモデル属性をセットするヘルパ&#10;    private fun addCommonAttributes(model: Model) {&#10;        val screens = contentItemService.getAll()&#10;        model.addAttribute(&quot;screens&quot;, screens)&#10;        val menus = menuService.getAll()&#10;        model.addAttribute(&quot;menus&quot;, menus)&#10;        // visibleMenus: Home 画面などで表示するメニューは、画面管理で割り当てられている menuName のみ&#10;        val assignedMenuNames = screens.mapNotNull { it.menuName }.map { it.trim() }.filter { it.isNotEmpty() }.toSet()&#10;        val visibleMenus = if (assignedMenuNames.isEmpty()) {&#10;            // none assigned -&gt; empty list (do not show menus on Home)&#10;            emptyList&lt;com.example.demo.model.Menu&gt;()&#10;        } else {&#10;            menus.filter { it.name != null &amp;&amp; assignedMenuNames.contains(it.name!!.trim()) }&#10;        }&#10;        model.addAttribute(&quot;visibleMenus&quot;, visibleMenus)&#10;    }&#10;&#10;    @GetMapping(ApplicationConstants.ROOT)&#10;    fun root(model: Model): String {&#10;        addCommonAttributes(model)&#10;        // ensure template has these attributes to avoid Thymeleaf evaluating a null fragment name&#10;        model.addAttribute(&quot;currentScreen&quot;, &quot;&quot;)&#10;        model.addAttribute(&quot;selectedScreenName&quot;, &quot;メニューを選択&quot;)&#10;        model.addAttribute(&quot;currentScreenPath&quot;, &quot;&quot;)&#10;        return &quot;main&quot;&#10;    }&#10;&#10;    @GetMapping(ApplicationConstants.CONTENT)&#10;    fun selectItem(&#10;        @RequestParam(name = &quot;screenName&quot;, defaultValue = &quot;未選択&quot;) @Size(max = 255, message = &quot;screenName: 255文字以内で入力してください&quot;) screenName: String,&#10;        model: Model&#10;    ): String {&#10;        model.addAttribute(&quot;errorMessage&quot;, null)&#10;        addCommonAttributes(model)&#10;&#10;        // currentScreen は未選択なら空文字、それ以外はクエリ値をそのまま使う&#10;        val current = if (screenName == &quot;未選択&quot;) &quot;&quot; else screenName&#10;        model.addAttribute(&quot;currentScreen&quot;, current)&#10;&#10;        // --- 変更: selectedScreenName は画面名ではなく menuName を優先して表示する ---&#10;        // Find the ContentItem once and reuse. Use trimmed comparison to be tolerant of whitespace.&#10;        val requestedName = if (screenName == &quot;未選択&quot;) null else screenName.trim()&#10;        val found = if (requestedName == null) null else contentItemService.getAll().firstOrNull {&#10;            val itemName = it.itemName?.trim()&#10;            if (itemName == null) false else itemName == requestedName&#10;        }&#10;&#10;        // If the found item has a non-blank menuName, show that; otherwise fall back to screenName (or placeholder)&#10;        val selected = when {&#10;            requestedName == null -&gt; &quot;メニューを選択&quot;&#10;            found?.menuName?.trim()?.isNotEmpty() == true -&gt; found.menuName!!.trim()&#10;            else -&gt; requestedName&#10;        }&#10;        model.addAttribute(&quot;selectedScreenName&quot;, selected)&#10;&#10;        // 追加: 選択された画面名に対応する ContentItem を探して pathName を currentScreenPath としてモデルにセット&#10;        val currentPath = if (requestedName == null) {&#10;            &quot;&quot;&#10;        } else {&#10;            if (found == null) {&#10;                &quot;&quot;&#10;            } else {&#10;                val pn = found.pathName&#10;                // defensive: treat literal &quot;null&quot; (from bad DB values) as missing&#10;                val normalizedPn = pn?.trim()?.takeIf { it.isNotEmpty() &amp;&amp; !it.equals(&quot;null&quot;, ignoreCase = true) }&#10;                if (normalizedPn.isNullOrBlank()) {&#10;                    &quot;&quot;&#10;                } else {&#10;                    val candidate = normalizedPn&#10;                    val resourcePath = &quot;templates/fragments/${candidate}.html&quot;&#10;                    val res = ClassPathResource(resourcePath)&#10;                    if (res.exists()) candidate else {&#10;                        model.addAttribute(&quot;errorMessage&quot;, &quot;指定された画面（${candidate}）のテンプレートが見つかりません。&quot;)&#10;                        &quot;&quot;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        model.addAttribute(&quot;currentScreenPath&quot;, currentPath)&#10;&#10;        return &quot;main&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt" />
              <option name="originalContent" value="package com.example.demo.config&#10;&#10;import io.undertow.server.DefaultByteBufferPool&#10;import io.undertow.websockets.jsr.WebSocketDeploymentInfo&#10;import org.springframework.boot.web.embedded.undertow.UndertowDeploymentInfoCustomizer&#10;import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory&#10;import org.springframework.context.annotation.Bean&#10;import org.springframework.context.annotation.Configuration&#10;import org.springframework.core.env.Environment&#10;import org.springframework.util.unit.DataSize&#10;&#10;@Configuration&#10;class UndertowWebSocketConfig(&#10;    private val env: Environment&#10;) {&#10;&#10;    @Bean&#10;    fun undertowServletWebServerFactory(): UndertowServletWebServerFactory {&#10;        val factory = UndertowServletWebServerFactory()&#10;&#10;        val customizer = UndertowDeploymentInfoCustomizer { di -&gt;&#10;            // Undertow の WebSocket 用バッファプールを設定（警告 UT026010 の解消）&#10;            val direct = true // 直接バッファ（GC 負荷軽減）&#10;            val dataSize: DataSize = env.getProperty(&#10;                &quot;server.undertow.buffer-size&quot;,&#10;                DataSize::class.java,&#10;                DataSize.ofKilobytes(16)&#10;            )&#10;            val bufferSize: Int = dataSize.toBytes().coerceAtMost(Int.MAX_VALUE.toLong()).toInt()&#10;            val wsInfo = WebSocketDeploymentInfo()&#10;            wsInfo.buffers = DefaultByteBufferPool(direct, bufferSize)&#10;            (di as io.undertow.servlet.api.DeploymentInfo)&#10;                .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, wsInfo)&#10;        }&#10;&#10;        factory.setDeploymentInfoCustomizers(listOf(customizer))&#10;        return factory&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo.config&#13;&#10;&#13;&#10;import org.springframework.context.annotation.Configuration&#13;&#10;&#13;&#10;@Configuration&#13;&#10;class UndertowWebSocketConfig {&#13;&#10;    // Undertow を削除したため本クラスは空のプレースホルダです。&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/static/js/main.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/static/js/main.js" />
              <option name="originalContent" value="// アプリ共通のメインクライアントスクリプト（main.js）&#10;// - 目的: ページ初期化・イベント委譲・サイドバーのメニュー注入・フラグメントのスクリプト読み込み・pwgenの初期化など&#10;// - パフォーマンス配慮: requestIdleCallback を利用してアイドル時に初期化を行い、ユーザー体験を向上します&#10;// - フォールバック: DOMContentLoaded / load / setTimeout / MutationObserver により動的挿入や遅延読み込みに対応します&#10;&#10;(function () {&#10;  'use strict';&#10;&#10;  // Ensure pages restored from bfcache are reloaded to avoid showing stale or protected content&#10;  window.addEventListener('pageshow', function (event) {&#10;    if (event.persisted) {&#10;      window.location.reload();&#10;    }&#10;  });&#10;&#10;  // Utility: debounce to avoid frequent calls during resize&#10;  const debounce = (fn, wait) =&gt; {&#10;    let t = null;&#10;    return function (...args) {&#10;      const ctx = this;&#10;      clearTimeout(t);&#10;      t = setTimeout(() =&gt; fn.apply(ctx, args), wait);&#10;    };&#10;  };&#10;&#10;  // Utility: fetch with timeout using AbortController&#10;  const fetchWithTimeout = (resource, options = {}, timeout = 10000) =&gt; {&#10;    const controller = new AbortController();&#10;    const id = setTimeout(() =&gt; controller.abort(), timeout);&#10;    const signal = controller.signal;&#10;    return fetch(resource, Object.assign({}, options, { signal })).finally(() =&gt; clearTimeout(id));&#10;  };&#10;&#10;  // runWhenIdle: ページがアイドルになったら初期化処理を実行するヘルパ&#10;  const runWhenIdle = (fn) =&gt; {&#10;    if ('requestIdleCallback' in window) {&#10;      requestIdleCallback(fn, { timeout: 200 });&#10;    } else {&#10;      if (document.readyState === 'loading') {&#10;        document.addEventListener('DOMContentLoaded', fn);&#10;      } else {&#10;        fn();&#10;      }&#10;    }&#10;  };&#10;&#10;  runWhenIdle(function () {&#10;    // イベント委譲ヘルパ（selector に発火する evt を handler に委譲）&#10;    // selector: CSS selector string OR DOM element OR window&#10;    const on = (selector, evt, handler) =&gt; {&#10;      if (selector === window || selector === document) {&#10;        (selector || window).addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // if selector is an element&#10;      if (selector instanceof Element) {&#10;        selector.addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // delegation on document&#10;      document.addEventListener(evt, function (e) {&#10;        const target = e.target;&#10;        const el = target.closest(selector);&#10;        if (el) handler.call(el, e);&#10;      });&#10;    };&#10;&#10;    // PC: サイドバー折りたたみ切り替え&#10;    on('#pcSidebarToggle', 'click', () =&gt; {&#10;      const sidebar = document.getElementById('sidebarMenu');&#10;      if (sidebar) sidebar.classList.toggle('is-collapsed');&#10;      const mains = document.querySelectorAll('.main-content');&#10;      mains.forEach(m =&gt; m.classList.toggle('is-collapsed'));&#10;    });&#10;&#10;    // サイドバーの Offcanvas を初期化&#10;    const sidebarEl = document.getElementById('sidebarMenu');&#10;    if (sidebarEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Offcanvas) {&#10;      bootstrap.Offcanvas.getOrCreateInstance(sidebarEl);&#10;    }&#10;&#10;    // 追加: 選択中のサイドバーメニュー名（画面管理で登録した menuName）&#10;    let selectedSidebarMenu = null;&#10;&#10;    // サイドバーにサーバー上のメニュー（画面管理で登録された menuName の集合）を表示する&#10;    async function loadAndRenderSidebarMenus() {&#10;      try {&#10;        const path = window.location &amp;&amp; window.location.pathname ? window.location.pathname : '';&#10;        // do not inject or modify manage page sidebar (manage page has its own sidebar content)&#10;        if (path === '/manage' || path.startsWith('/manage')) return;&#10;&#10;        const resp = await fetch('/api/content/all');&#10;        if (!resp.ok) return; // fail silently&#10;        const screens = await resp.json();&#10;        if (!Array.isArray(screens)) return;&#10;&#10;        // derive unique menu names from screens' menuName&#10;        const menuNames = screens.map(s =&gt; s.menuName).filter(Boolean);&#10;        const uniqueMenuNames = Array.from(new Set(menuNames));&#10;&#10;        const ul = document.querySelector('#sidebarMenu .offcanvas-body ul.nav');&#10;        if (!ul) return;&#10;&#10;        // Remove previous injected menu items (marked with data-injected=&quot;true&quot;)&#10;        Array.from(ul.querySelectorAll('li[data-injected=&quot;true&quot;]')).forEach(n =&gt; n.remove());&#10;&#10;        // Find the Manage item to insert before it, otherwise append&#10;        const manageLi = Array.from(ul.querySelectorAll('li')).find(li =&gt; {&#10;          const a = li.querySelector('a');&#10;          return a &amp;&amp; a.getAttribute('href') === '/manage';&#10;        });&#10;&#10;        uniqueMenuNames.forEach(menuName =&gt; {&#10;          const label = String(menuName).trim();&#10;          if (!label) return;&#10;          // avoid duplicates: check for either server-rendered or previously injected items&#10;          const existsByMenuAttr = ul.querySelector('a[data-menu-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByScreenAttr = ul.querySelector('a[data-screen-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByText = Array.from(ul.querySelectorAll('a')).some(a =&gt; (a.textContent || '').trim() === label);&#10;          if (existsByMenuAttr || existsByScreenAttr || existsByText) return;&#10;&#10;          const li = document.createElement('li');&#10;          li.className = 'nav-item';&#10;          li.setAttribute('data-injected', 'true');&#10;          const a = document.createElement('a');&#10;          a.className = 'nav-link text-dark sidebar-menu-link';&#10;          a.href = '#';&#10;          a.setAttribute('data-menu-name', label);&#10;          a.innerHTML = '&lt;i class=&quot;bi bi-folder&quot;&gt;&lt;/i&gt; &lt;span&gt;' + label + '&lt;/span&gt;';&#10;          // clicking a sidebar menu will set it as selected and open the content selection modal&#10;          a.addEventListener('click', function (ev) {&#10;            ev.preventDefault();&#10;            selectedSidebarMenu = label;&#10;            // open modal&#10;            const modalEl = document.getElementById('scrollableModal');&#10;            if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;              // populate modal body before showing&#10;              // fetch filtered screens from server for the selected menu&#10;              (async function () {&#10;                try {&#10;                  const resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(label), { credentials: 'same-origin' }, 10000);&#10;                  if (resp &amp;&amp; resp.ok) {&#10;                    const filteredScreens = await resp.json();&#10;                    populateContentModal(selectedSidebarMenu, filteredScreens);&#10;                  } else {&#10;                    // fallback to using previously fetched screens if server call fails&#10;                    populateContentModal(selectedSidebarMenu, screens);&#10;                  }&#10;                } catch (e) {&#10;                  populateContentModal(selectedSidebarMenu, screens);&#10;                }&#10;              })();&#10;               const inst = bootstrap.Modal.getOrCreateInstance(modalEl);&#10;               inst.show();&#10;             } else {&#10;               // fallback: populate only&#10;              (async function () {&#10;                try {&#10;                  const resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(label), { credentials: 'same-origin' }, 10000);&#10;                  if (resp &amp;&amp; resp.ok) {&#10;                    const filteredScreens = await resp.json();&#10;                    populateContentModal(selectedSidebarMenu, filteredScreens);&#10;                    return;&#10;                  }&#10;                } catch (e) { /* ignore */ }&#10;                populateContentModal(selectedSidebarMenu, screens);&#10;              })();&#10;             }&#10;           });&#10;&#10;          if (manageLi) ul.insertBefore(li, manageLi);&#10;          else ul.appendChild(li);&#10;          li.appendChild(a);&#10;        });&#10;&#10;      } catch (e) {&#10;        // silent fail&#10;      }&#10;    }&#10;&#10;    // Populate the content selection modal list-group with screens filtered by menuName&#10;    function populateContentModal(menuName, screens) {&#10;      try {&#10;        const modal = document.getElementById('scrollableModal');&#10;        if (!modal) return;&#10;        const listGroup = modal.querySelector('.modal-body .list-group');&#10;        if (!listGroup) return;&#10;        // clear existing&#10;        listGroup.innerHTML = '';&#10;        let items = screens || [];&#10;        // If no menu selected, prompt user to select a menu from the sidebar&#10;        if (!menuName) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = 'サイドバーのメニューを選択してください';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        if (menuName) {&#10;          items = items.filter(s =&gt; s.menuName === menuName);&#10;        }&#10;        if (!items.length) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = '該当する画面がありません';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        items.forEach(s =&gt; {&#10;          const a = document.createElement('a');&#10;          a.className = 'list-group-item list-group-item-action text-start content-item';&#10;          a.href = '#';&#10;          a.setAttribute('data-screen-name', s.itemName);&#10;          a.textContent = s.itemName || '(無題)';&#10;          listGroup.appendChild(a);&#10;        });&#10;      } catch (e) { /* ignore */ }&#10;    }&#10;&#10;    // 初回ロードでメニューを描画&#10;    loadAndRenderSidebarMenus();&#10;&#10;    // When header's select button opens modal, populate it using currently cached screens&#10;    const itemSelectButton = document.getElementById('itemSelectButton');&#10;    if (itemSelectButton) {&#10;      itemSelectButton.addEventListener('click', async function () {&#10;        // fetch screens and populate modal, filter by selectedSidebarMenu if set&#10;        const selectedSidebarMenu = itemSelectButton.innerText;&#10;        try {&#10;          let resp;&#10;          if (selectedSidebarMenu) {&#10;            resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(selectedSidebarMenu), { credentials: 'same-origin' }, 10000);&#10;          } else {&#10;            resp = await fetchWithTimeout('/api/content/all', { credentials: 'same-origin' }, 10000);&#10;          }&#10;          if (!resp || !resp.ok) return;&#10;          const screens = await resp.json();&#10;          populateContentModal(selectedSidebarMenu, screens);&#10;        } catch (e) { /* ignore */ }&#10;      });&#10;    }&#10;&#10;    // BroadcastChannel で同一ブラウザ内のタブからの通知を受け取る（フォールバックで storage もある）&#10;    if (typeof BroadcastChannel !== 'undefined') {&#10;      try {&#10;        const bch = new BroadcastChannel('menus-channel');&#10;        bch.addEventListener('message', function (ev) {&#10;          if (!ev) return;&#10;          if (ev.data === 'menus-updated') loadAndRenderSidebarMenus();&#10;        });&#10;      } catch (err) {&#10;        // ignore&#10;      }&#10;    }&#10;&#10;    // 他タブで menus が更新されたときに再描画する（storage イベントは同一タブでは発火しない点に注意）&#10;    window.addEventListener('storage', function (e) {&#10;      if (!e) return;&#10;      if (e.key === 'menus-updated') {&#10;        loadAndRenderSidebarMenus();&#10;      }&#10;    });&#10;&#10;    // ビューポート高さをCSSカスタムプロパティに反映&#10;    const setAppHeight = () =&gt; document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);&#10;    window.addEventListener('resize', debounce(setAppHeight, 150));&#10;    setAppHeight();&#10;&#10;    // Fallback: ensure header moves to bottom on mobile via class toggle&#10;    const mobileQuery = '(max-width: 767.98px)';&#10;    const mq = window.matchMedia ? window.matchMedia(mobileQuery) : null;&#10;    const applyHeaderBottomClass = () =&gt; {&#10;      if (!mq) return;&#10;      if (mq.matches) {&#10;        document.body.classList.add('header-bottom');&#10;      } else {&#10;        document.body.classList.remove('header-bottom');&#10;      }&#10;    };&#10;    if (mq) {&#10;      // initial&#10;      applyHeaderBottomClass();&#10;      // listen for changes&#10;      if (typeof mq.addEventListener === 'function') {&#10;        mq.addEventListener('change', applyHeaderBottomClass);&#10;      } else if (typeof mq.addListener === 'function') {&#10;        mq.addListener(applyHeaderBottomClass);&#10;      }&#10;    }&#10;&#10;    // トースト表示&#10;    on('#liveToastBtn', 'click', () =&gt; {&#10;      const el = document.getElementById('liveToast');&#10;      if (el &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Toast) bootstrap.Toast.getOrCreateInstance(el).show();&#10;    });&#10;&#10;    // モーダル別にバックドロップの色を切替&#10;    const errorModal = document.getElementById('errorModal');&#10;    if (errorModal) errorModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-error');&#10;    });&#10;&#10;    const scrollableModal = document.getElementById('scrollableModal');&#10;    if (scrollableModal) scrollableModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-select');&#10;    });&#10;&#10;    // モーダル内のアイテム選択で /content をAJAX遷移（失敗時は通常遷移）。fetchWithTimeout を使いタイムアウトをつける&#10;    on('.content-item', 'click', function (e) {&#10;      e.preventDefault();&#10;      const screenName = this.dataset.screenName;&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; {&#10;          if (!resp.ok) {&#10;            // レスポンスが正常でない場合はフルナビゲーションへフォールバック&#10;            return Promise.reject('network');&#10;          }&#10;          return resp.text();&#10;        })&#10;        .then(responseText =&gt; {&#10;          try {&#10;            const parser = new DOMParser();&#10;            const doc = parser.parseFromString(responseText, 'text/html');&#10;            const newMain = doc.querySelector('main.main-content');&#10;            const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;            if (newMain) {&#10;              const oldMain = document.querySelector('main.main-content');&#10;              if (oldMain) oldMain.replaceWith(newMain);&#10;              const selectedEl = document.getElementById('selectedItemName');&#10;              if (selectedEl) selectedEl.textContent = newSelectedName;&#10;              const modalEl = document.getElementById('scrollableModal');&#10;              if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;                const modalInst = bootstrap.Modal.getInstance(modalEl) || bootstrap.Modal.getOrCreateInstance(modalEl);&#10;                modalInst.hide();&#10;              }&#10;              // Load fragment scripts, wait for pwgen elements, then initialize&#10;              (async function () {&#10;                await loadAndRunScriptsFromFragment(newMain);&#10;                try {&#10;                  // call init immediately and schedule retries to catch late DOM insertion&#10;                  try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;                } catch (err) { /* initPwgen failed (silently) */ }&#10;              })();&#10;              history.pushState({ screenName }, '', url.toString());&#10;              return;&#10;            }&#10;          } catch (err) {&#10;            // パース失敗時はフル遷移&#10;          }&#10;          window.location.href = url.toString();&#10;        })&#10;        .catch(() =&gt; {&#10;          window.location.href = url.toString();&#10;        });&#10;    });&#10;&#10;    // 戻る/進むで main コンテンツを再取得&#10;    window.addEventListener('popstate', function (event) {&#10;      const state = event.state || {};&#10;      const screenName = state.screenName || null;&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; resp.text())&#10;        .then(responseText =&gt; {&#10;          const parser = new DOMParser();&#10;          const doc = parser.parseFromString(responseText, 'text/html');&#10;          const newMain = doc.querySelector('main.main-content');&#10;          const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;          if (newMain) {&#10;            const oldMain = document.querySelector('main.main-content');&#10;            if (oldMain) oldMain.replaceWith(newMain);&#10;            const selectedEl = document.getElementById('selectedItemName');&#10;            if (selectedEl) selectedEl.textContent = newSelectedName;&#10;            // Load fragment scripts, wait for pwgen elements, then initialize&#10;            (async function () {&#10;              await loadAndRunScriptsFromFragment(newMain);&#10;              try {&#10;                try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;              } catch (err) { /* initPwgen failed (silently) */ }&#10;            })();&#10;          }&#10;        })&#10;        .catch(() =&gt; {});&#10;    });&#10;&#10;    // helper: load scripts found inside a fragment (execute inline scripts, load external ones)&#10;    function loadAndRunScriptsFromFragment(fragmentRoot) {&#10;      try {&#10;        const scripts = Array.from(fragmentRoot.querySelectorAll('script'));&#10;        const loads = [];&#10;        scripts.forEach(s =&gt; {&#10;          const src = s.getAttribute('src');&#10;          if (src) {&#10;            // resolve absolute URL (browser will handle relative)&#10;            const abs = src;&#10;            // skip if already present&#10;            if (!document.querySelector('script[src=&quot;' + abs + '&quot;]')) {&#10;              loads.push(new Promise((res) =&gt; {&#10;                const sc = document.createElement('script');&#10;                sc.src = abs;&#10;                sc.async = false; // preserve execution order&#10;                sc.onload = () =&gt; res();&#10;                sc.onerror = () =&gt; { /* failed to load script (silently) */ res(); };&#10;                document.head.appendChild(sc);&#10;              }));&#10;            }&#10;          } else {&#10;            // inline script: execute by creating a new script element&#10;            try {&#10;              const inline = document.createElement('script');&#10;              inline.text = s.textContent || s.innerText || '';&#10;              document.head.appendChild(inline);&#10;              // no need to wait&#10;            } catch (e) { /* ignore */ }&#10;          }&#10;        });&#10;        return Promise.all(loads);&#10;      } catch (e) {&#10;        return Promise.resolve();&#10;      }&#10;    }&#10;&#10;&#10;  });&#10;&#10;})();&#10;&#10;// End of main.js&#10;" />
              <option name="updatedContent" value="// アプリ共通のメインクライアントスクリプト（main.js）&#10;// - 目的: ページ初期化・イベント委譲・サイドバーのメニュー注入・フラグメントのスクリプト読み込み・pwgenの初期化など&#10;// - パフォーマンス配慮: requestIdleCallback を利用してアイドル時に初期化を行い、ユーザー体験を向上します&#10;// - フォールバック: DOMContentLoaded / load / setTimeout / MutationObserver により動的挿入や遅延読み込みに対応します&#10;&#10;(function () {&#10;  'use strict';&#10;&#10;  // Ensure pages restored from bfcache are reloaded to avoid showing stale or protected content&#10;  window.addEventListener('pageshow', function (event) {&#10;    if (event.persisted) {&#10;      window.location.reload();&#10;    }&#10;  });&#10;&#10;  // Utility: debounce to avoid frequent calls during resize&#10;  const debounce = (fn, wait) =&gt; {&#10;    let t = null;&#10;    return function (...args) {&#10;      const ctx = this;&#10;      clearTimeout(t);&#10;      t = setTimeout(() =&gt; fn.apply(ctx, args), wait);&#10;    };&#10;  };&#10;&#10;  // Utility: fetch with timeout using AbortController&#10;  const fetchWithTimeout = (resource, options = {}, timeout = 10000) =&gt; {&#10;    const controller = new AbortController();&#10;    const id = setTimeout(() =&gt; controller.abort(), timeout);&#10;    const signal = controller.signal;&#10;    return fetch(resource, Object.assign({}, options, { signal })).finally(() =&gt; clearTimeout(id));&#10;  };&#10;&#10;  // runWhenIdle: ページがアイドルになったら初期化処理を実行するヘルパ&#10;  const runWhenIdle = (fn) =&gt; {&#10;    if ('requestIdleCallback' in window) {&#10;      requestIdleCallback(fn, { timeout: 200 });&#10;    } else {&#10;      if (document.readyState === 'loading') {&#10;        document.addEventListener('DOMContentLoaded', fn);&#10;      } else {&#10;        fn();&#10;      }&#10;    }&#10;  };&#10;&#10;  runWhenIdle(function () {&#10;    // イベント委譲ヘルパ（selector に発火する evt を handler に委譲）&#10;    // selector: CSS selector string OR DOM element OR window&#10;    const on = (selector, evt, handler) =&gt; {&#10;      if (selector === window || selector === document) {&#10;        (selector || window).addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // if selector is an element&#10;      if (selector instanceof Element) {&#10;        selector.addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // delegation on document&#10;      document.addEventListener(evt, function (e) {&#10;        const target = e.target;&#10;        const el = target.closest(selector);&#10;        if (el) handler.call(el, e);&#10;      });&#10;    };&#10;&#10;    // PC: サイドバー折りたたみ切り替え&#10;    on('#pcSidebarToggle', 'click', () =&gt; {&#10;      const sidebar = document.getElementById('sidebarMenu');&#10;      if (sidebar) sidebar.classList.toggle('is-collapsed');&#10;      const mains = document.querySelectorAll('.main-content');&#10;      mains.forEach(m =&gt; m.classList.toggle('is-collapsed'));&#10;    });&#10;&#10;    // サイドバーの Offcanvas を初期化&#10;    const sidebarEl = document.getElementById('sidebarMenu');&#10;    if (sidebarEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Offcanvas) {&#10;      bootstrap.Offcanvas.getOrCreateInstance(sidebarEl);&#10;    }&#10;&#10;    // 追加: 選択中のサイドバーメニュー名（画面管理で登録した menuName）&#10;    let selectedSidebarMenu = null;&#10;&#10;    // サイドバーにサーバー上のメニュー（画面管理で登録された menuName の集合）を表示する&#10;    async function loadAndRenderSidebarMenus() {&#10;      try {&#10;        const path = window.location &amp;&amp; window.location.pathname ? window.location.pathname : '';&#10;        // do not inject or modify manage page sidebar (manage page has its own sidebar content)&#10;        if (path === '/manage' || path.startsWith('/manage')) return;&#10;&#10;        const resp = await fetch('/api/content/all');&#10;        if (!resp.ok) return; // fail silently&#10;        const screens = await resp.json();&#10;        if (!Array.isArray(screens)) return;&#10;&#10;        // derive unique menu names from screens' menuName&#10;        const menuNames = screens.map(s =&gt; s.menuName).filter(Boolean);&#10;        const uniqueMenuNames = Array.from(new Set(menuNames));&#10;&#10;        const ul = document.querySelector('#sidebarMenu .offcanvas-body ul.nav');&#10;        if (!ul) return;&#10;&#10;        // Remove previous injected menu items (marked with data-injected=&quot;true&quot;)&#10;        Array.from(ul.querySelectorAll('li[data-injected=&quot;true&quot;]')).forEach(n =&gt; n.remove());&#10;&#10;        // Find the Manage item to insert before it, otherwise append&#10;        const manageLi = Array.from(ul.querySelectorAll('li')).find(li =&gt; {&#10;          const a = li.querySelector('a');&#10;          return a &amp;&amp; a.getAttribute('href') === '/manage';&#10;        });&#10;&#10;        uniqueMenuNames.forEach(menuName =&gt; {&#10;          const label = String(menuName).trim();&#10;          if (!label) return;&#10;          // avoid duplicates: check for either server-rendered or previously injected items&#10;          const existsByMenuAttr = ul.querySelector('a[data-menu-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByScreenAttr = ul.querySelector('a[data-screen-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByText = Array.from(ul.querySelectorAll('a')).some(a =&gt; (a.textContent || '').trim() === label);&#10;          if (existsByMenuAttr || existsByScreenAttr || existsByText) return;&#10;&#10;          const li = document.createElement('li');&#10;          li.className = 'nav-item';&#10;          li.setAttribute('data-injected', 'true');&#10;          const a = document.createElement('a');&#10;          a.className = 'nav-link text-dark sidebar-menu-link';&#10;          a.href = '#';&#10;          a.setAttribute('data-menu-name', label);&#10;          a.innerHTML = '&lt;i class=&quot;bi bi-folder&quot;&gt;&lt;/i&gt; &lt;span&gt;' + label + '&lt;/span&gt;';&#10;          // clicking a sidebar menu will set it as selected and open the content selection modal&#10;          a.addEventListener('click', function (ev) {&#10;            ev.preventDefault();&#10;            selectedSidebarMenu = label;&#10;            // open modal&#10;            const modalEl = document.getElementById('scrollableModal');&#10;            if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;              // populate modal body before showing&#10;              // fetch filtered screens from server for the selected menu&#10;              (async function () {&#10;                try {&#10;                  const resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(label), { credentials: 'same-origin' }, 10000);&#10;                  if (resp &amp;&amp; resp.ok) {&#10;                    const filteredScreens = await resp.json();&#10;                    populateContentModal(selectedSidebarMenu, filteredScreens);&#10;                  } else {&#10;                    // fallback to using previously fetched screens if server call fails&#10;                    populateContentModal(selectedSidebarMenu, screens);&#10;                  }&#10;                } catch (e) {&#10;                  populateContentModal(selectedSidebarMenu, screens);&#10;                }&#10;              })();&#10;               const inst = bootstrap.Modal.getOrCreateInstance(modalEl);&#10;               inst.show();&#10;             } else {&#10;               // fallback: populate only&#10;              (async function () {&#10;                try {&#10;                  const resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(label), { credentials: 'same-origin' }, 10000);&#10;                  if (resp &amp;&amp; resp.ok) {&#10;                    const filteredScreens = await resp.json();&#10;                    populateContentModal(selectedSidebarMenu, filteredScreens);&#10;                    return;&#10;                  }&#10;                } catch (e) { /* ignore */ }&#10;                populateContentModal(selectedSidebarMenu, screens);&#10;              })();&#10;             }&#10;           });&#10;&#10;          if (manageLi) ul.insertBefore(li, manageLi);&#10;          else ul.appendChild(li);&#10;          li.appendChild(a);&#10;        });&#10;&#10;      } catch (e) {&#10;        // silent fail&#10;      }&#10;    }&#10;&#10;    // Populate the content selection modal list-group with screens filtered by menuName&#10;    function populateContentModal(menuName, screens) {&#10;      try {&#10;        const modal = document.getElementById('scrollableModal');&#10;        if (!modal) return;&#10;        const listGroup = modal.querySelector('.modal-body .list-group');&#10;        if (!listGroup) return;&#10;        // clear existing&#10;        listGroup.innerHTML = '';&#10;        let items = screens || [];&#10;        // If no menu selected, prompt user to select a menu from the sidebar&#10;        if (!menuName) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = 'サイドバーのメニューを選択してください';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        if (menuName) {&#10;          items = items.filter(s =&gt; s.menuName === menuName);&#10;        }&#10;        if (!items.length) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = '該当する画面がありません';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        items.forEach(s =&gt; {&#10;          const a = document.createElement('a');&#10;          a.className = 'list-group-item list-group-item-action text-start content-item';&#10;          a.href = '#';&#10;          a.setAttribute('data-screen-name', s.itemName);&#10;          a.textContent = s.itemName || '(無題)';&#10;          listGroup.appendChild(a);&#10;        });&#10;      } catch (e) { /* ignore */ }&#10;    }&#10;&#10;    // 初回ロードでメニューを描画&#10;    loadAndRenderSidebarMenus();&#10;&#10;    // When header's select button opens modal, populate it using currently cached screens&#10;    const itemSelectButton = document.getElementById('itemSelectButton');&#10;    if (itemSelectButton) {&#10;      itemSelectButton.addEventListener('click', async function () {&#10;        // fetch screens and populate modal, filter by selectedSidebarMenu if set&#10;        // Prefer the sidebar-selection variable if it's been set; otherwise use the header label&#10;        const headerLabelEl = document.getElementById('selectedItemName');&#10;        const headerLabel = headerLabelEl ? (headerLabelEl.textContent || '').trim() : '';&#10;        // ignore placeholder texts&#10;        const headerName = (headerLabel &amp;&amp; headerLabel !== '画面を選択' &amp;&amp; headerLabel !== 'メニューを選択') ? headerLabel : '';&#10;        const menuToUse = selectedSidebarMenu || headerName || '';&#10;        try {&#10;          let resp;&#10;          if (menuToUse) {&#10;            resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(menuToUse), { credentials: 'same-origin' }, 10000);&#10;          } else {&#10;            resp = await fetchWithTimeout('/api/content/all', { credentials: 'same-origin' }, 10000);&#10;          }&#10;          if (!resp || !resp.ok) return;&#10;          const screens = await resp.json();&#10;          populateContentModal(menuToUse, screens);&#10;        } catch (e) { /* ignore */ }&#10;      });&#10;    }&#10;&#10;    // BroadcastChannel で同一ブラウザ内のタブからの通知を受け取る（フォールバックで storage もある）&#10;    if (typeof BroadcastChannel !== 'undefined') {&#10;      try {&#10;        const bch = new BroadcastChannel('menus-channel');&#10;        bch.addEventListener('message', function (ev) {&#10;          if (!ev) return;&#10;          if (ev.data === 'menus-updated') loadAndRenderSidebarMenus();&#10;        });&#10;      } catch (err) {&#10;        // ignore&#10;      }&#10;    }&#10;&#10;    // 他タブで menus が更新されたときに再描画する（storage イベントは同一タブでは発火しない点に注意）&#10;    window.addEventListener('storage', function (e) {&#10;      if (!e) return;&#10;      if (e.key === 'menus-updated') {&#10;        loadAndRenderSidebarMenus();&#10;      }&#10;    });&#10;&#10;    // ビューポート高さをCSSカスタムプロパティに反映&#10;    const setAppHeight = () =&gt; document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);&#10;    window.addEventListener('resize', debounce(setAppHeight, 150));&#10;    setAppHeight();&#10;&#10;    // Fallback: ensure header moves to bottom on mobile via class toggle&#10;    const mobileQuery = '(max-width: 767.98px)';&#10;    const mq = window.matchMedia ? window.matchMedia(mobileQuery) : null;&#10;    const applyHeaderBottomClass = () =&gt; {&#10;      if (!mq) return;&#10;      if (mq.matches) {&#10;        document.body.classList.add('header-bottom');&#10;      } else {&#10;        document.body.classList.remove('header-bottom');&#10;      }&#10;    };&#10;    if (mq) {&#10;      // initial&#10;      applyHeaderBottomClass();&#10;      // listen for changes&#10;      if (typeof mq.addEventListener === 'function') {&#10;        mq.addEventListener('change', applyHeaderBottomClass);&#10;      } else if (typeof mq.addListener === 'function') {&#10;        mq.addListener(applyHeaderBottomClass);&#10;      }&#10;    }&#10;&#10;    // トースト表示&#10;    on('#liveToastBtn', 'click', () =&gt; {&#10;      const el = document.getElementById('liveToast');&#10;      if (el &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Toast) bootstrap.Toast.getOrCreateInstance(el).show();&#10;    });&#10;&#10;    // モーダル別にバックドロップの色を切替&#10;    const errorModal = document.getElementById('errorModal');&#10;    if (errorModal) errorModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-error');&#10;    });&#10;&#10;    const scrollableModal = document.getElementById('scrollableModal');&#10;    if (scrollableModal) scrollableModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-select');&#10;    });&#10;&#10;    // モーダル内のアイテム選択で /content をAJAX遷移（失敗時は通常遷移）。fetchWithTimeout を使いタイムアウトをつける&#10;    on('.content-item', 'click', function (e) {&#10;      e.preventDefault();&#10;      const screenName = this.dataset.screenName;&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; {&#10;          if (!resp.ok) {&#10;            // レスポンスが正常でない場合はフルナビゲーションへフォールバック&#10;            return Promise.reject('network');&#10;          }&#10;          return resp.text();&#10;        })&#10;        .then(responseText =&gt; {&#10;          try {&#10;            const parser = new DOMParser();&#10;            const doc = parser.parseFromString(responseText, 'text/html');&#10;            const newMain = doc.querySelector('main.main-content');&#10;            const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;            if (newMain) {&#10;              const oldMain = document.querySelector('main.main-content');&#10;              if (oldMain) oldMain.replaceWith(newMain);&#10;              const selectedEl = document.getElementById('selectedItemName');&#10;              if (selectedEl) selectedEl.textContent = newSelectedName;&#10;              const modalEl = document.getElementById('scrollableModal');&#10;              if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;                const modalInst = bootstrap.Modal.getInstance(modalEl) || bootstrap.Modal.getOrCreateInstance(modalEl);&#10;                modalInst.hide();&#10;              }&#10;              // Load fragment scripts, wait for pwgen elements, then initialize&#10;              (async function () {&#10;                await loadAndRunScriptsFromFragment(newMain);&#10;                try {&#10;                  // call init immediately and schedule retries to catch late DOM insertion&#10;                  try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;                } catch (err) { /* initPwgen failed (silently) */ }&#10;              })();&#10;              history.pushState({ screenName }, '', url.toString());&#10;              return;&#10;            }&#10;          } catch (err) {&#10;            // パース失敗時はフル遷移&#10;          }&#10;          window.location.href = url.toString();&#10;        })&#10;        .catch(() =&gt; {&#10;          window.location.href = url.toString();&#10;        });&#10;    });&#10;&#10;    // 戻る/進むで main コンテンツを再取得&#10;    window.addEventListener('popstate', function (event) {&#10;      const state = event.state || {};&#10;      const screenName = state.screenName || null;&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; resp.text())&#10;        .then(responseText =&gt; {&#10;          const parser = new DOMParser();&#10;          const doc = parser.parseFromString(responseText, 'text/html');&#10;          const newMain = doc.querySelector('main.main-content');&#10;          const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;          if (newMain) {&#10;            const oldMain = document.querySelector('main.main-content');&#10;            if (oldMain) oldMain.replaceWith(newMain);&#10;            const selectedEl = document.getElementById('selectedItemName');&#10;            if (selectedEl) selectedEl.textContent = newSelectedName;&#10;            // Load fragment scripts, wait for pwgen elements, then initialize&#10;            (async function () {&#10;              await loadAndRunScriptsFromFragment(newMain);&#10;              try {&#10;                try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;              } catch (err) { /* initPwgen failed (silently) */ }&#10;            })();&#10;          }&#10;        })&#10;        .catch(() =&gt; {});&#10;    });&#10;&#10;    // helper: load scripts found inside a fragment (execute inline scripts, load external ones)&#10;    function loadAndRunScriptsFromFragment(fragmentRoot) {&#10;      try {&#10;        const scripts = Array.from(fragmentRoot.querySelectorAll('script'));&#10;        const loads = [];&#10;        scripts.forEach(s =&gt; {&#10;          const src = s.getAttribute('src');&#10;          if (src) {&#10;            // resolve absolute URL (browser will handle relative)&#10;            const abs = src;&#10;            // skip if already present&#10;            if (!document.querySelector('script[src=&quot;' + abs + '&quot;]')) {&#10;              loads.push(new Promise((res) =&gt; {&#10;                const sc = document.createElement('script');&#10;                sc.src = abs;&#10;                sc.async = false; // preserve execution order&#10;                sc.onload = () =&gt; res();&#10;                sc.onerror = () =&gt; { /* failed to load script (silently) */ res(); };&#10;                document.head.appendChild(sc);&#10;              }));&#10;            }&#10;          } else {&#10;            // inline script: execute by creating a new script element&#10;            try {&#10;              const inline = document.createElement('script');&#10;              inline.text = s.textContent || s.innerText || '';&#10;              document.head.appendChild(inline);&#10;              // no need to wait&#10;            } catch (e) { /* ignore */ }&#10;          }&#10;        });&#10;        return Promise.all(loads);&#10;      } catch (e) {&#10;        return Promise.resolve();&#10;      }&#10;    }&#10;&#10;&#10;  });&#10;&#10;})();&#10;&#10;// End of main.js&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>