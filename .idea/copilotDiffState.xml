<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/resources/static/js/main.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/static/js/main.js" />
              <option name="originalContent" value="// アプリ共通のメインクライアントスクリプト（main.js）&#10;// - 目的: ページ初期化・イベント委譲・サイドバーのメニュー注入・フラグメントのスクリプト読み込み・pwgenの初期化など&#10;// - パフォーマンス配慮: requestIdleCallback を利用してアイドル時に初期化を行い、ユーザー体験を向上します&#10;// - フォールバック: DOMContentLoaded / load / setTimeout / MutationObserver により動的挿入や遅延読み込みに対応します&#10;&#10;(function () {&#10;  'use strict';&#10;&#10;  // Ensure pages restored from bfcache are reloaded to avoid showing stale or protected content&#10;  window.addEventListener('pageshow', function (event) {&#10;    if (event.persisted) {&#10;      window.location.reload();&#10;    }&#10;  });&#10;&#10;  // Utility: debounce to avoid frequent calls during resize&#10;  const debounce = (fn, wait) =&gt; {&#10;    let t = null;&#10;    return function (...args) {&#10;      const ctx = this;&#10;      clearTimeout(t);&#10;      t = setTimeout(() =&gt; fn.apply(ctx, args), wait);&#10;    };&#10;  };&#10;&#10;  // Utility: fetch with timeout using AbortController&#10;  const fetchWithTimeout = (resource, options = {}, timeout = 10000) =&gt; {&#10;    const controller = new AbortController();&#10;    const id = setTimeout(() =&gt; controller.abort(), timeout);&#10;    const signal = controller.signal;&#10;    return fetch(resource, Object.assign({}, options, { signal })).finally(() =&gt; clearTimeout(id));&#10;  };&#10;&#10;  // Simple in-memory cache for content API responses&#10;  const contentCache = {&#10;    ttl: 30000, // 30 seconds&#10;    all: { data: null, ts: 0 }, // cache for /all&#10;    byMenu: new Map(), // key: menuName -&gt; { data, ts }&#10;    clear() {&#10;      this.all = { data: null, ts: 0 };&#10;      this.byMenu.clear();&#10;    }&#10;  };&#10;&#10;  async function getContentScreens(menuName) {&#10;    const now = Date.now();&#10;    try {&#10;      if (!menuName) {&#10;        // use /api/content/all&#10;        if (contentCache.all.data &amp;&amp; (now - contentCache.all.ts) &lt; contentCache.ttl) {&#10;          return contentCache.all.data;&#10;        }&#10;        const resp = await fetchWithTimeout('/api/content/all', { credentials: 'same-origin' }, 10000);&#10;        if (!resp || !resp.ok) return [];&#10;        const data = await resp.json();&#10;        contentCache.all = { data, ts: now };&#10;        return data;&#10;      } else {&#10;        const key = String(menuName);&#10;        const hit = contentCache.byMenu.get(key);&#10;        if (hit &amp;&amp; (now - hit.ts) &lt; contentCache.ttl) {&#10;          return hit.data;&#10;        }&#10;        const resp = await fetchWithTimeout('/api/content?menuName=' + encodeURIComponent(key), { credentials: 'same-origin' }, 10000);&#10;        if (!resp || !resp.ok) return [];&#10;        const data = await resp.json();&#10;        contentCache.byMenu.set(key, { data, ts: now });&#10;        return data;&#10;      }&#10;    } catch (_) {&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // runWhenIdle: ページがアイドルになったら初期化処理を実行するヘルパ&#10;  const runWhenIdle = (fn) =&gt; {&#10;    if ('requestIdleCallback' in window) {&#10;      requestIdleCallback(fn, { timeout: 200 });&#10;    } else {&#10;      if (document.readyState === 'loading') {&#10;        document.addEventListener('DOMContentLoaded', fn);&#10;      } else {&#10;        fn();&#10;      }&#10;    }&#10;  };&#10;&#10;  runWhenIdle(function () {&#10;    // イベント委譲ヘルパ（selector に発火する evt を handler に委譲）&#10;    // selector: CSS selector string OR DOM element OR window&#10;    const on = (selector, evt, handler) =&gt; {&#10;      if (selector === window || selector === document) {&#10;        (selector || window).addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // if selector is an element&#10;      if (selector instanceof Element) {&#10;        selector.addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // delegation on document&#10;      document.addEventListener(evt, function (e) {&#10;        const target = e.target;&#10;        const el = target.closest(selector);&#10;        if (el) handler.call(el, e);&#10;      });&#10;    };&#10;&#10;    // PC: サイドバー折りたたみ切り替え&#10;    on('#pcSidebarToggle', 'click', () =&gt; {&#10;      const sidebar = document.getElementById('sidebarMenu');&#10;      if (sidebar) sidebar.classList.toggle('is-collapsed');&#10;      const mains = document.querySelectorAll('.main-content');&#10;      mains.forEach(m =&gt; m.classList.toggle('is-collapsed'));&#10;    });&#10;&#10;    // サイドバーの Offcanvas を初期化&#10;    const sidebarEl = document.getElementById('sidebarMenu');&#10;    if (sidebarEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Offcanvas) {&#10;      bootstrap.Offcanvas.getOrCreateInstance(sidebarEl);&#10;    }&#10;&#10;    // 追加: 選択中のサイドバーメニュー名（画面管理で登録した menuName）&#10;    let selectedSidebarMenu = null;&#10;&#10;    // サイドバーにサーバー上のメニュー（画面管理で登録された menuName の集合）を表示する&#10;    async function loadAndRenderSidebarMenus() {&#10;      try {&#10;        const path = window.location &amp;&amp; window.location.pathname ? window.location.pathname : '';&#10;        // do not inject or modify manage page sidebar (manage page has its own sidebar content)&#10;        if (path === '/manage' || path.startsWith('/manage')) return;&#10;&#10;        // まず有効なメニュー一覧を取得&#10;        let validMenuNames = [];&#10;        try {&#10;          const menusResp = await fetchWithTimeout('/api/menus/all', { credentials: 'same-origin' }, 10000);&#10;          if (menusResp &amp;&amp; menusResp.ok) {&#10;            const menus = await menusResp.json();&#10;            validMenuNames = Array.isArray(menus) ? menus.map(m =&gt; m.name).filter(Boolean) : [];&#10;          }&#10;        } catch (e) {&#10;          console.warn('Failed to fetch valid menus:', e);&#10;        }&#10;&#10;        const screens = await getContentScreens('');&#10;        if (!Array.isArray(screens)) return;&#10;&#10;        // exclude screens without a valid pathName, itemName, and menuName&#10;        const hasValidData = (s) =&gt; {&#10;          // Check pathName validity&#10;          const pn = (s &amp;&amp; s.pathName != null) ? String(s.pathName).trim() : '';&#10;          const hasValidPath = pn &amp;&amp; pn.toLowerCase() !== 'null' &amp;&amp; pn.length &gt; 0;&#10;&#10;          // Check itemName validity (screen name must be set in management screen)&#10;          const itemName = (s &amp;&amp; s.itemName != null) ? String(s.itemName).trim() : '';&#10;          const hasValidItemName = itemName &amp;&amp; itemName.length &gt; 0;&#10;&#10;          // Check menuName validity&#10;          const menuNameValue = (s &amp;&amp; s.menuName != null) ? String(s.menuName).trim() : '';&#10;          const hasValidMenuName = menuNameValue &amp;&amp; menuNameValue.length &gt; 0;&#10;&#10;          // 削除されたメニューを除外：メニューマスターに存在するもののみ有効とする&#10;          const isValidMenu = validMenuNames.length === 0 || validMenuNames.includes(menuNameValue);&#10;&#10;          return hasValidPath &amp;&amp; hasValidItemName &amp;&amp; hasValidMenuName &amp;&amp; isValidMenu;&#10;        };&#10;        const validScreens = screens.filter(hasValidData);&#10;&#10;        // derive unique menu names from screens' menuName (only from screens with valid data and valid menus)&#10;        const menuNames = validScreens.map(s =&gt; s.menuName).filter(Boolean);&#10;        const uniqueMenuNames = Array.from(new Set(menuNames));&#10;&#10;        const ul = document.querySelector('#sidebarMenu .offcanvas-body ul.nav');&#10;        if (!ul) return;&#10;&#10;        // Remove previous injected menu items (marked with data-injected=&quot;true&quot;)&#10;        Array.from(ul.querySelectorAll('li[data-injected=&quot;true&quot;]')).forEach(n =&gt; n.remove());&#10;&#10;        // Find the Manage item to insert before it, otherwise append&#10;        const manageLi = Array.from(ul.querySelectorAll('li')).find(li =&gt; {&#10;          const a = li.querySelector('a');&#10;          return a &amp;&amp; a.getAttribute('href') === '/manage';&#10;        });&#10;&#10;        uniqueMenuNames.forEach(menuName =&gt; {&#10;          const label = String(menuName).trim();&#10;          if (!label) return;&#10;          // avoid duplicates: check for either server-rendered or previously injected items&#10;          const existsByMenuAttr = ul.querySelector('a[data-menu-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByScreenAttr = ul.querySelector('a[data-screen-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByText = Array.from(ul.querySelectorAll('a')).some(a =&gt; (a.textContent || '').trim() === label);&#10;          if (existsByMenuAttr || existsByScreenAttr || existsByText) return;&#10;&#10;          const li = document.createElement('li');&#10;          li.className = 'nav-item';&#10;          li.setAttribute('data-injected', 'true');&#10;          const a = document.createElement('a');&#10;          a.className = 'nav-link text-dark sidebar-menu-link';&#10;          a.href = '#';&#10;          a.setAttribute('data-menu-name', label);&#10;          a.innerHTML = '&lt;i class=&quot;bi bi-folder&quot;&gt;&lt;/i&gt; &lt;span&gt;' + label + '&lt;/span&gt;';&#10;          // clicking a sidebar menu will set it as selected and open the content selection modal&#10;          a.addEventListener('click', function (ev) {&#10;            ev.preventDefault();&#10;            selectedSidebarMenu = label;&#10;            // open modal&#10;            const modalEl = document.getElementById('scrollableModal');&#10;            if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;              // populate modal body before showing&#10;              // fetch filtered screens from server for the selected menu&#10;              (async function () {&#10;                try {&#10;                  const filteredScreens = await getContentScreens(label);&#10;                  // apply same data validation filter on modal items&#10;                  const filteredValid = Array.isArray(filteredScreens) ? filteredScreens.filter(hasValidData) : [];&#10;                  if (filteredValid.length) {&#10;                    populateContentModal(selectedSidebarMenu, filteredValid);&#10;                  } else {&#10;                    populateContentModal(selectedSidebarMenu, validScreens);&#10;                  }&#10;                } catch (e) { populateContentModal(selectedSidebarMenu, validScreens); }&#10;               })();&#10;               const inst = bootstrap.Modal.getOrCreateInstance(modalEl);&#10;               inst.show();&#10;             } else {&#10;               // fallback: populate only&#10;              (async function () {&#10;                try {&#10;                  const filteredScreens = await getContentScreens(label);&#10;                  const filteredValid = Array.isArray(filteredScreens) ? filteredScreens.filter(hasValidData) : [];&#10;                  if (filteredValid.length) {&#10;                    populateContentModal(selectedSidebarMenu, filteredValid);&#10;                    return;&#10;                  }&#10;                } catch (e) { /* ignore */ }&#10;                populateContentModal(selectedSidebarMenu, validScreens);&#10;               })();&#10;             }&#10;           });&#10;&#10;          if (manageLi) ul.insertBefore(li, manageLi);&#10;          else ul.appendChild(li);&#10;          li.appendChild(a);&#10;        });&#10;&#10;      } catch (e) {&#10;        // silent fail&#10;      }&#10;    }&#10;&#10;    // Populate the content selection modal list-group with screens filtered by menuName&#10;    function populateContentModal(menuName, screens) {&#10;      try {&#10;        const modal = document.getElementById('scrollableModal');&#10;        if (!modal) return;&#10;        // Update the small label in the modal header to show which sidebar/menu is being displayed&#10;        try {&#10;          const sidebarLabelEl = modal.querySelector('#modalSidebarName');&#10;          if (sidebarLabelEl) sidebarLabelEl.textContent = menuName ? String(menuName) : '（全て）';&#10;        } catch (_) { /* ignore */ }&#10;        const listGroup = modal.querySelector('.modal-body .list-group');&#10;        if (!listGroup) return;&#10;        // clear existing&#10;        listGroup.innerHTML = '';&#10;        let items = screens || [];&#10;        // If no menu selected, prompt user to select a menu from the sidebar&#10;        if (!menuName) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = 'サイドバーのメニューを選択してください';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        if (menuName) {&#10;          items = items.filter(s =&gt; s.menuName === menuName);&#10;        }&#10;        // exclude items without valid pathName AND valid itemName - use same validation as sidebar menu loading&#10;        items = items.filter(s =&gt; {&#10;          // Check pathName validity&#10;          const pn = (s &amp;&amp; s.pathName != null) ? String(s.pathName).trim() : '';&#10;          const hasValidPath = pn &amp;&amp; pn.toLowerCase() !== 'null' &amp;&amp; pn.length &gt; 0;&#10;&#10;          // Check itemName validity (screen name must be set in management screen)&#10;          const itemName = (s &amp;&amp; s.itemName != null) ? String(s.itemName).trim() : '';&#10;          const hasValidItemName = itemName &amp;&amp; itemName.length &gt; 0;&#10;&#10;          // Check menuName validity&#10;          const menuNameValue = (s &amp;&amp; s.menuName != null) ? String(s.menuName).trim() : '';&#10;          const hasValidMenuName = menuNameValue &amp;&amp; menuNameValue.length &gt; 0;&#10;&#10;          return hasValidPath &amp;&amp; hasValidItemName &amp;&amp; hasValidMenuName;&#10;        });&#10;        if (!items.length) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = '該当する画面がありません';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        items.forEach(s =&gt; {&#10;          const a = document.createElement('a');&#10;          a.className = 'list-group-item list-group-item-action text-start content-item';&#10;          a.href = '#';&#10;          a.setAttribute('data-screen-name', s.itemName);&#10;          // Preserve the menuName on each item so the click handler can update the header to show menuName&#10;          if (menuName) a.setAttribute('data-menu-name', menuName);&#10;          a.textContent = s.itemName || '(無題)';&#10;          listGroup.appendChild(a);&#10;        });&#10;      } catch (e) { /* ignore */ }&#10;    }&#10;&#10;    // 初回ロードでメニューを描画&#10;    loadAndRenderSidebarMenus();&#10;&#10;    // When header's select button opens modal, populate it using currently cached screens&#10;    const itemSelectButton = document.getElementById('itemSelectButton');&#10;    if (itemSelectButton) {&#10;      itemSelectButton.addEventListener('click', async function () {&#10;        // fetch screens and populate modal, filter by selectedSidebarMenu if set&#10;        // Prefer the sidebar-selection variable if it's been set; otherwise use the header label&#10;        const headerLabelEl = document.getElementById('selectedItemName');&#10;        const headerLabel = headerLabelEl ? (headerLabelEl.textContent || '').trim() : '';&#10;        // ignore placeholder texts&#10;        const headerName = (headerLabel &amp;&amp; headerLabel !== '画面を選択' &amp;&amp; headerLabel !== 'メニューを選択') ? headerLabel : '';&#10;        const menuToUse = selectedSidebarMenu || headerName || '';&#10;        try {&#10;          const screens = await getContentScreens(menuToUse);&#10;           populateContentModal(menuToUse, screens);&#10;        } catch (e) { /* ignore */ }&#10;      });&#10;    }&#10;&#10;    // BroadcastChannel で同一ブラウザ内のタブからの通知を受け取る（フォールバックで storage もある）&#10;    if (typeof BroadcastChannel !== 'undefined') {&#10;      try {&#10;        const bch = new BroadcastChannel('menus-channel');&#10;        bch.addEventListener('message', function (ev) {&#10;          if (!ev) return;&#10;          if (ev.data === 'menus-updated') {&#10;            contentCache.clear();&#10;            loadAndRenderSidebarMenus();&#10;          }&#10;        });&#10;      } catch (err) {&#10;        // ignore&#10;      }&#10;    }&#10;&#10;    // 他タブで menus が更新されたときに再描画する（storage イベントは同一タブでは発火しない点に注意）&#10;    window.addEventListener('storage', function (e) {&#10;      if (!e) return;&#10;      if (e.key === 'menus-updated') {&#10;        contentCache.clear();&#10;        loadAndRenderSidebarMenus();&#10;      }&#10;    });&#10;&#10;    // ビューポート高さをCSSカスタムプロパティに反映&#10;    const setAppHeight = () =&gt; document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);&#10;    window.addEventListener('resize', debounce(setAppHeight, 150));&#10;    setAppHeight();&#10;&#10;    // Fallback: ensure header moves to bottom on mobile via class toggle&#10;    const mobileQuery = '(max-width: 767.98px)';&#10;    const mq = window.matchMedia ? window.matchMedia(mobileQuery) : null;&#10;    const applyHeaderBottomClass = () =&gt; {&#10;      if (!mq) return;&#10;      if (mq.matches) {&#10;        document.body.classList.add('header-bottom');&#10;      } else {&#10;        document.body.classList.remove('header-bottom');&#10;      }&#10;    };&#10;    if (mq) {&#10;      // initial&#10;      applyHeaderBottomClass();&#10;      // listen for changes&#10;      if (typeof mq.addEventListener === 'function') {&#10;        mq.addEventListener('change', applyHeaderBottomClass);&#10;      } else if (typeof mq.addListener === 'function') {&#10;        mq.addListener(applyHeaderBottomClass);&#10;      }&#10;    }&#10;&#10;    // トースト表示&#10;    on('#liveToastBtn', 'click', () =&gt; {&#10;      const el = document.getElementById('liveToast');&#10;      if (el &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Toast) bootstrap.Toast.getOrCreateInstance(el).show();&#10;    });&#10;&#10;    // モーダル別にバックドロップの色を切替&#10;    const errorModal = document.getElementById('errorModal');&#10;    if (errorModal) errorModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-error');&#10;    });&#10;&#10;    const scrollableModal = document.getElementById('scrollableModal');&#10;    if (scrollableModal) scrollableModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-select');&#10;    });&#10;&#10;    // Invalidate caches when menus are updated or modal is hidden (optional)&#10;    if (scrollableModal) scrollableModal.addEventListener('hidden.bs.modal', () =&gt; {&#10;      // keep selection, but we could clear selection if desired&#10;    });&#10;&#10;    // モーダル内のアイテム選択で /content をAJAX遷移（失敗時は通常遷移）。fetchWithTimeout を使いタイムアウトをつける&#10;    on('.content-item', 'click', function (e) {&#10;      e.preventDefault();&#10;      const screenName = this.dataset.screenName;&#10;      const clickedMenuName = (this.dataset &amp;&amp; this.dataset.menuName) ? this.dataset.menuName : (selectedSidebarMenu || '');&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; {&#10;          if (!resp.ok) {&#10;            // レスポンスが正常でない場合はフルナビゲーションへフォールバック&#10;            return Promise.reject('network');&#10;          }&#10;          return resp.text();&#10;        })&#10;        .then(responseText =&gt; {&#10;          try {&#10;            const parser = new DOMParser();&#10;            const doc = parser.parseFromString(responseText, 'text/html');&#10;            const newMain = doc.querySelector('main.main-content');&#10;            const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;            if (newMain) {&#10;              const oldMain = document.querySelector('main.main-content');&#10;              if (oldMain) oldMain.replaceWith(newMain);&#10;              const selectedEl = document.getElementById('selectedItemName');&#10;              if (selectedEl) {&#10;                // Prefer the clicked menuName (if available) to show menu name in the header; otherwise use server-provided value&#10;                selectedEl.textContent = clickedMenuName || newSelectedName;&#10;              }&#10;              const modalEl = document.getElementById('scrollableModal');&#10;              if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;                const modalInst = bootstrap.Modal.getInstance(modalEl) || bootstrap.Modal.getOrCreateInstance(modalEl);&#10;                modalInst.hide();&#10;              }&#10;              // Load fragment scripts, wait for pwgen elements, then initialize&#10;              (async function () {&#10;                await loadAndRunScriptsFromFragment(newMain);&#10;                try {&#10;                  // call init immediately and schedule retries to catch late DOM insertion&#10;                  try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;                } catch (err) { /* initPwgen failed (silently) */ }&#10;              })();&#10;              // Keep menuName in history state so popstate can restore header label correctly&#10;              history.pushState({ screenName, menuName: clickedMenuName }, '', url.toString());&#10;               return;&#10;            }&#10;          } catch (err) {&#10;            // パース失敗時はフル遷移&#10;          }&#10;          window.location.href = url.toString();&#10;        })&#10;        .catch(() =&gt; {&#10;          window.location.href = url.toString();&#10;        });&#10;    });&#10;&#10;    // 戻る/進むで main コンテンツを再取得&#10;    window.addEventListener('popstate', function (event) {&#10;      const state = event.state || {};&#10;      const screenName = state.screenName || null;&#10;      const stateMenuName = state.menuName || null;&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; resp.text())&#10;        .then(responseText =&gt; {&#10;          const parser = new DOMParser();&#10;          const doc = parser.parseFromString(responseText, 'text/html');&#10;          const newMain = doc.querySelector('main.main-content');&#10;          const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;          if (newMain) {&#10;            const oldMain = document.querySelector('main.main-content');&#10;            if (oldMain) oldMain.replaceWith(newMain);&#10;            const selectedEl = document.getElementById('selectedItemName');&#10;            if (selectedEl) selectedEl.textContent = (stateMenuName || newSelectedName);&#10;            // Load fragment scripts, wait for pwgen elements, then initialize&#10;            (async function () {&#10;              await loadAndRunScriptsFromFragment(newMain);&#10;              try {&#10;                try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;              } catch (err) { /* initPwgen failed (silently) */ }&#10;            })();&#10;          }&#10;        })&#10;        .catch(() =&gt; {});&#10;    });&#10;&#10;    // helper: load scripts found inside a fragment (execute inline scripts, load external ones)&#10;    function loadAndRunScriptsFromFragment(fragmentRoot) {&#10;      try {&#10;        const scripts = Array.from(fragmentRoot.querySelectorAll('script'));&#10;        const loads = [];&#10;        scripts.forEach(s =&gt; {&#10;          const src = s.getAttribute('src');&#10;          if (src) {&#10;            // resolve absolute URL (browser will handle relative)&#10;            const abs = src;&#10;            // skip if already present&#10;            if (!document.querySelector('script[src=&quot;' + abs + '&quot;]')) {&#10;              loads.push(new Promise((res) =&gt; {&#10;                const sc = document.createElement('script');&#10;                sc.src = abs;&#10;                sc.async = false; // preserve execution order&#10;                sc.onload = () =&gt; res();&#10;                sc.onerror = () =&gt; { /* failed to load script (silently) */ res(); };&#10;                document.head.appendChild(sc);&#10;              }));&#10;            }&#10;          } else {&#10;            // inline script: execute by creating a new script element&#10;            try {&#10;              const inline = document.createElement('script');&#10;              inline.text = s.textContent || s.innerText || '';&#10;              document.head.appendChild(inline);&#10;              // no need to wait&#10;            } catch (e) { /* ignore */ }&#10;          }&#10;        });&#10;        return Promise.all(loads);&#10;      } catch (e) {&#10;        return Promise.resolve();&#10;      }&#10;    }&#10;&#10;&#10;  });&#10;&#10;})();&#10;&#10;// End of main.js&#10;" />
              <option name="updatedContent" value="// アプリ共通のメインクライアントスクリプト（main.js）&#10;// - 目的: ページ初期化・イベント委譲・サイドバーのメニュー注入・フラグメントのスクリプト読み込み・pwgenの初期化など&#10;// - パフォーマンス配慮: requestIdleCallback を利用してアイドル時に初期化を行い、ユーザー体験を向上します&#10;// - フォールバック: DOMContentLoaded / load / setTimeout / MutationObserver により動的挿入や遅延読み込みに対応します&#10;&#10;(function () {&#10;  'use strict';&#10;&#10;  // Ensure pages restored from bfcache are reloaded to avoid showing stale or protected content&#10;  window.addEventListener('pageshow', function (event) {&#10;    if (event.persisted) {&#10;      window.location.reload();&#10;    }&#10;  });&#10;&#10;  // Utility: debounce to avoid frequent calls during resize&#10;  const debounce = (fn, wait) =&gt; {&#10;    let t = null;&#10;    return function (...args) {&#10;      const ctx = this;&#10;      clearTimeout(t);&#10;      t = setTimeout(() =&gt; fn.apply(ctx, args), wait);&#10;    };&#10;  };&#10;&#10;  // Utility: fetch with timeout using AbortController&#10;  const fetchWithTimeout = (resource, options = {}, timeout = 10000) =&gt; {&#10;    const controller = new AbortController();&#10;    const id = setTimeout(() =&gt; controller.abort(), timeout);&#10;    const signal = controller.signal;&#10;    return fetch(resource, Object.assign({}, options, { signal })).finally(() =&gt; clearTimeout(id));&#10;  };&#10;&#10;  // Simple in-memory cache for content API responses&#10;  const contentCache = {&#10;    ttl: 30000, // 30 seconds&#10;    all: { data: null, ts: 0 }, // cache for /all&#10;    byMenu: new Map(), // key: menuName -&gt; { data, ts }&#10;    clear() {&#10;      this.all = { data: null, ts: 0 };&#10;      this.byMenu.clear();&#10;    }&#10;  };&#10;&#10;  async function getContentScreens(menuName) {&#10;    const now = Date.now();&#10;    try {&#10;      if (!menuName) {&#10;        // use /api/content/all&#10;        if (contentCache.all.data &amp;&amp; (now - contentCache.all.ts) &lt; contentCache.ttl) {&#10;          return contentCache.all.data;&#10;        }&#10;        const resp = await fetchWithTimeout('/api/content/all', { credentials: 'same-origin' }, 10000);&#10;        if (!resp || !resp.ok) return [];&#10;        const data = await resp.json();&#10;        contentCache.all = { data, ts: now };&#10;        return data;&#10;      } else {&#10;        // メニュー名が指定されている場合は、常に全データを取得してクライアントサイドでフィルタリング&#10;        // これにより、サーバーサイドのフィルタリングの問題を回避&#10;        if (contentCache.all.data &amp;&amp; (now - contentCache.all.ts) &lt; contentCache.ttl) {&#10;          const allData = contentCache.all.data;&#10;          return Array.isArray(allData) ? allData.filter(item =&gt; &#10;            item &amp;&amp; item.menuName &amp;&amp; String(item.menuName).trim() === String(menuName).trim()&#10;          ) : [];&#10;        }&#10;        &#10;        const resp = await fetchWithTimeout('/api/content/all', { credentials: 'same-origin' }, 10000);&#10;        if (!resp || !resp.ok) return [];&#10;        const data = await resp.json();&#10;        contentCache.all = { data, ts: now };&#10;        &#10;        // クライアントサイドで厳密にフィルタリング&#10;        return Array.isArray(data) ? data.filter(item =&gt; &#10;          item &amp;&amp; item.menuName &amp;&amp; String(item.menuName).trim() === String(menuName).trim()&#10;        ) : [];&#10;      }&#10;    } catch (_) {&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // runWhenIdle: ページがアイドルになったら初期化処理を実行するヘルパ&#10;  const runWhenIdle = (fn) =&gt; {&#10;    if ('requestIdleCallback' in window) {&#10;      requestIdleCallback(fn, { timeout: 200 });&#10;    } else {&#10;      if (document.readyState === 'loading') {&#10;        document.addEventListener('DOMContentLoaded', fn);&#10;      } else {&#10;        fn();&#10;      }&#10;    }&#10;  };&#10;&#10;  runWhenIdle(function () {&#10;    // イベント委譲ヘルパ（selector に発火する evt を handler に委譲）&#10;    // selector: CSS selector string OR DOM element OR window&#10;    const on = (selector, evt, handler) =&gt; {&#10;      if (selector === window || selector === document) {&#10;        (selector || window).addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // if selector is an element&#10;      if (selector instanceof Element) {&#10;        selector.addEventListener(evt, handler);&#10;        return;&#10;      }&#10;&#10;      // delegation on document&#10;      document.addEventListener(evt, function (e) {&#10;        const target = e.target;&#10;        const el = target.closest(selector);&#10;        if (el) handler.call(el, e);&#10;      });&#10;    };&#10;&#10;    // PC: サイドバー折りたたみ切り替え&#10;    on('#pcSidebarToggle', 'click', () =&gt; {&#10;      const sidebar = document.getElementById('sidebarMenu');&#10;      if (sidebar) sidebar.classList.toggle('is-collapsed');&#10;      const mains = document.querySelectorAll('.main-content');&#10;      mains.forEach(m =&gt; m.classList.toggle('is-collapsed'));&#10;    });&#10;&#10;    // サイドバーの Offcanvas を初期化&#10;    const sidebarEl = document.getElementById('sidebarMenu');&#10;    if (sidebarEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Offcanvas) {&#10;      bootstrap.Offcanvas.getOrCreateInstance(sidebarEl);&#10;    }&#10;&#10;    // 追加: 選択中のサイドバーメニュー名（画面管理で登録した menuName）&#10;    let selectedSidebarMenu = null;&#10;&#10;    // サイドバーにサーバー上のメニュー（画面管理で登録された menuName の集合）を表示する&#10;    async function loadAndRenderSidebarMenus() {&#10;      try {&#10;        const path = window.location &amp;&amp; window.location.pathname ? window.location.pathname : '';&#10;        // do not inject or modify manage page sidebar (manage page has its own sidebar content)&#10;        if (path === '/manage' || path.startsWith('/manage')) return;&#10;&#10;        // まず有効なメニュー一覧を取得&#10;        let validMenuNames = [];&#10;        try {&#10;          const menusResp = await fetchWithTimeout('/api/menus/all', { credentials: 'same-origin' }, 10000);&#10;          if (menusResp &amp;&amp; menusResp.ok) {&#10;            const menus = await menusResp.json();&#10;            validMenuNames = Array.isArray(menus) ? menus.map(m =&gt; m.name).filter(Boolean) : [];&#10;          }&#10;        } catch (e) {&#10;          console.warn('Failed to fetch valid menus:', e);&#10;        }&#10;&#10;        const screens = await getContentScreens('');&#10;        if (!Array.isArray(screens)) return;&#10;&#10;        // exclude screens without a valid pathName, itemName, and menuName&#10;        const hasValidData = (s) =&gt; {&#10;          // Check pathName validity&#10;          const pn = (s &amp;&amp; s.pathName != null) ? String(s.pathName).trim() : '';&#10;          const hasValidPath = pn &amp;&amp; pn.toLowerCase() !== 'null' &amp;&amp; pn.length &gt; 0;&#10;&#10;          // Check itemName validity (screen name must be set in management screen)&#10;          const itemName = (s &amp;&amp; s.itemName != null) ? String(s.itemName).trim() : '';&#10;          const hasValidItemName = itemName &amp;&amp; itemName.length &gt; 0;&#10;&#10;          // Check menuName validity&#10;          const menuNameValue = (s &amp;&amp; s.menuName != null) ? String(s.menuName).trim() : '';&#10;          const hasValidMenuName = menuNameValue &amp;&amp; menuNameValue.length &gt; 0;&#10;&#10;          // 削除されたメニューを除外：メニューマスターに存在するもののみ有効とする&#10;          const isValidMenu = validMenuNames.length === 0 || validMenuNames.includes(menuNameValue);&#10;&#10;          return hasValidPath &amp;&amp; hasValidItemName &amp;&amp; hasValidMenuName &amp;&amp; isValidMenu;&#10;        };&#10;        const validScreens = screens.filter(hasValidData);&#10;&#10;        // derive unique menu names from screens' menuName (only from screens with valid data and valid menus)&#10;        const menuNames = validScreens.map(s =&gt; s.menuName).filter(Boolean);&#10;        const uniqueMenuNames = Array.from(new Set(menuNames));&#10;&#10;        const ul = document.querySelector('#sidebarMenu .offcanvas-body ul.nav');&#10;        if (!ul) return;&#10;&#10;        // Remove previous injected menu items (marked with data-injected=&quot;true&quot;)&#10;        Array.from(ul.querySelectorAll('li[data-injected=&quot;true&quot;]')).forEach(n =&gt; n.remove());&#10;&#10;        // Find the Manage item to insert before it, otherwise append&#10;        const manageLi = Array.from(ul.querySelectorAll('li')).find(li =&gt; {&#10;          const a = li.querySelector('a');&#10;          return a &amp;&amp; a.getAttribute('href') === '/manage';&#10;        });&#10;&#10;        uniqueMenuNames.forEach(menuName =&gt; {&#10;          const label = String(menuName).trim();&#10;          if (!label) return;&#10;          // avoid duplicates: check for either server-rendered or previously injected items&#10;          const existsByMenuAttr = ul.querySelector('a[data-menu-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByScreenAttr = ul.querySelector('a[data-screen-name=&quot;' + CSS.escape(label) + '&quot;]');&#10;          const existsByText = Array.from(ul.querySelectorAll('a')).some(a =&gt; (a.textContent || '').trim() === label);&#10;          if (existsByMenuAttr || existsByScreenAttr || existsByText) return;&#10;&#10;          const li = document.createElement('li');&#10;          li.className = 'nav-item';&#10;          li.setAttribute('data-injected', 'true');&#10;          const a = document.createElement('a');&#10;          a.className = 'nav-link text-dark sidebar-menu-link';&#10;          a.href = '#';&#10;          a.setAttribute('data-menu-name', label);&#10;          a.innerHTML = '&lt;i class=&quot;bi bi-folder&quot;&gt;&lt;/i&gt; &lt;span&gt;' + label + '&lt;/span&gt;';&#10;          // clicking a sidebar menu will set it as selected and open the content selection modal&#10;          a.addEventListener('click', function (ev) {&#10;            ev.preventDefault();&#10;            selectedSidebarMenu = label;&#10;            // open modal&#10;            const modalEl = document.getElementById('scrollableModal');&#10;            if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;              // populate modal body before showing&#10;              // fetch filtered screens from server for the selected menu&#10;              (async function () {&#10;                try {&#10;                  const filteredScreens = await getContentScreens(label);&#10;                  // apply same data validation filter on modal items&#10;                  const filteredValid = Array.isArray(filteredScreens) ? filteredScreens.filter(hasValidData) : [];&#10;                  if (filteredValid.length) {&#10;                    populateContentModal(selectedSidebarMenu, filteredValid);&#10;                  } else {&#10;                    populateContentModal(selectedSidebarMenu, validScreens);&#10;                  }&#10;                } catch (e) { populateContentModal(selectedSidebarMenu, validScreens); }&#10;               })();&#10;               const inst = bootstrap.Modal.getOrCreateInstance(modalEl);&#10;               inst.show();&#10;             } else {&#10;               // fallback: populate only&#10;              (async function () {&#10;                try {&#10;                  const filteredScreens = await getContentScreens(label);&#10;                  const filteredValid = Array.isArray(filteredScreens) ? filteredScreens.filter(hasValidData) : [];&#10;                  if (filteredValid.length) {&#10;                    populateContentModal(selectedSidebarMenu, filteredValid);&#10;                    return;&#10;                  }&#10;                } catch (e) { /* ignore */ }&#10;                populateContentModal(selectedSidebarMenu, validScreens);&#10;               })();&#10;             }&#10;           });&#10;&#10;          if (manageLi) ul.insertBefore(li, manageLi);&#10;          else ul.appendChild(li);&#10;          li.appendChild(a);&#10;        });&#10;&#10;      } catch (e) {&#10;        // silent fail&#10;      }&#10;    }&#10;&#10;    // Populate the content selection modal list-group with screens filtered by menuName&#10;    function populateContentModal(menuName, screens) {&#10;      try {&#10;        const modal = document.getElementById('scrollableModal');&#10;        if (!modal) return;&#10;        // Update the small label in the modal header to show which sidebar/menu is being displayed&#10;        try {&#10;          const sidebarLabelEl = modal.querySelector('#modalSidebarName');&#10;          if (sidebarLabelEl) sidebarLabelEl.textContent = menuName ? String(menuName) : '（全て）';&#10;        } catch (_) { /* ignore */ }&#10;        const listGroup = modal.querySelector('.modal-body .list-group');&#10;        if (!listGroup) return;&#10;        // clear existing&#10;        listGroup.innerHTML = '';&#10;        let items = screens || [];&#10;        &#10;        // デバッグ情報：受信したデータをログ出力&#10;        console.debug('populateContentModal called with:', { menuName, itemCount: items.length });&#10;        &#10;        // If no menu selected, prompt user to select a menu from the sidebar&#10;        if (!menuName) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = 'サイドバーのメニューを選択してください';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        &#10;        // 厳密なメニュー名フィルタリング：完全一致のみ&#10;        if (menuName) {&#10;          const originalCount = items.length;&#10;          items = items.filter(s =&gt; {&#10;            const itemMenuName = s &amp;&amp; s.menuName ? String(s.menuName).trim() : '';&#10;            const targetMenuName = String(menuName).trim();&#10;            return itemMenuName === targetMenuName;&#10;          });&#10;          console.debug('Menu filter applied:', { &#10;            menuName, &#10;            originalCount, &#10;            filteredCount: items.length,&#10;            filteredItems: items.map(s =&gt; ({ id: s.id, menuName: s.menuName, itemName: s.itemName, pathName: s.pathName }))&#10;          });&#10;        }&#10;        &#10;        // exclude items without valid pathName AND valid itemName - use same validation as sidebar menu loading&#10;        items = items.filter(s =&gt; {&#10;          // Check pathName validity&#10;          const pn = (s &amp;&amp; s.pathName != null) ? String(s.pathName).trim() : '';&#10;          const hasValidPath = pn &amp;&amp; pn.toLowerCase() !== 'null' &amp;&amp; pn.length &gt; 0;&#10;&#10;          // Check itemName validity (screen name must be set in management screen)&#10;          const itemName = (s &amp;&amp; s.itemName != null) ? String(s.itemName).trim() : '';&#10;          const hasValidItemName = itemName &amp;&amp; itemName.length &gt; 0;&#10;&#10;          // Check menuName validity&#10;          const menuNameValue = (s &amp;&amp; s.menuName != null) ? String(s.menuName).trim() : '';&#10;          const hasValidMenuName = menuNameValue &amp;&amp; menuNameValue.length &gt; 0;&#10;&#10;          return hasValidPath &amp;&amp; hasValidItemName &amp;&amp; hasValidMenuName;&#10;        });&#10;        &#10;        console.debug('Final validation applied:', { &#10;          finalCount: items.length,&#10;          finalItems: items.map(s =&gt; ({ id: s.id, menuName: s.menuName, itemName: s.itemName, pathName: s.pathName }))&#10;        });&#10;        &#10;        if (!items.length) {&#10;          const el = document.createElement('div');&#10;          el.className = 'list-group-item text-muted';&#10;          el.textContent = '該当する画面がありません';&#10;          listGroup.appendChild(el);&#10;          return;&#10;        }&#10;        items.forEach(s =&gt; {&#10;          const a = document.createElement('a');&#10;          a.className = 'list-group-item list-group-item-action text-start content-item';&#10;          a.href = '#';&#10;&#10;          // 一意性を確保するために、IDまたは画面名+パス名の組み合わせを使用&#10;          const uniqueKey = s.id ? String(s.id) : `${s.itemName}_${s.pathName}`;&#10;          a.setAttribute('data-screen-id', uniqueKey);&#10;          a.setAttribute('data-screen-name', s.itemName);&#10;          a.setAttribute('data-path-name', s.pathName || '');&#10;&#10;          // Preserve the menuName on each item so the click handler can update the header to show menuName&#10;          if (menuName) a.setAttribute('data-menu-name', menuName);&#10;&#10;          // 表示内容を改善：画面名とパス名を両方表示して区別しやすくする&#10;          const displayName = s.itemName || '(無題)';&#10;          const pathInfo = s.pathName ? ` (${s.pathName})` : '';&#10;          a.innerHTML = `&#10;            &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;&#10;              &lt;span class=&quot;fw-bold&quot;&gt;${displayName}&lt;/span&gt;&#10;              &lt;small class=&quot;text-muted&quot;&gt;${pathInfo}&lt;/small&gt;&#10;            &lt;/div&gt;&#10;          `;&#10;&#10;          listGroup.appendChild(a);&#10;        });&#10;      } catch (e) { &#10;        console.error('Error in populateContentModal:', e);&#10;      }&#10;    }&#10;&#10;    // 初回ロードでメニューを描画&#10;    loadAndRenderSidebarMenus();&#10;&#10;    // When header's select button opens modal, populate it using currently cached screens&#10;    const itemSelectButton = document.getElementById('itemSelectButton');&#10;    if (itemSelectButton) {&#10;      itemSelectButton.addEventListener('click', async function () {&#10;        // fetch screens and populate modal, filter by selectedSidebarMenu if set&#10;        // Prefer the sidebar-selection variable if it's been set; otherwise use the header label&#10;        const headerLabelEl = document.getElementById('selectedItemName');&#10;        const headerLabel = headerLabelEl ? (headerLabelEl.textContent || '').trim() : '';&#10;        // ignore placeholder texts&#10;        const headerName = (headerLabel &amp;&amp; headerLabel !== '画面を選択' &amp;&amp; headerLabel !== 'メニューを選択') ? headerLabel : '';&#10;        const menuToUse = selectedSidebarMenu || headerName || '';&#10;        try {&#10;          const screens = await getContentScreens(menuToUse);&#10;           populateContentModal(menuToUse, screens);&#10;        } catch (e) { /* ignore */ }&#10;      });&#10;    }&#10;&#10;    // BroadcastChannel で同一ブラウザ内のタブからの通知を受け取る（フォールバックで storage もある）&#10;    if (typeof BroadcastChannel !== 'undefined') {&#10;      try {&#10;        const bch = new BroadcastChannel('menus-channel');&#10;        bch.addEventListener('message', function (ev) {&#10;          if (!ev) return;&#10;          if (ev.data === 'menus-updated') {&#10;            contentCache.clear();&#10;            loadAndRenderSidebarMenus();&#10;          }&#10;        });&#10;      } catch (err) {&#10;        // ignore&#10;      }&#10;    }&#10;&#10;    // 他タブで menus が更新されたときに再描画する（storage イベントは同一タブでは発火しない点に注意）&#10;    window.addEventListener('storage', function (e) {&#10;      if (!e) return;&#10;      if (e.key === 'menus-updated') {&#10;        contentCache.clear();&#10;        loadAndRenderSidebarMenus();&#10;      }&#10;    });&#10;&#10;    // ビューポート高さをCSSカスタムプロパティに反映&#10;    const setAppHeight = () =&gt; document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);&#10;    window.addEventListener('resize', debounce(setAppHeight, 150));&#10;    setAppHeight();&#10;&#10;    // Fallback: ensure header moves to bottom on mobile via class toggle&#10;    const mobileQuery = '(max-width: 767.98px)';&#10;    const mq = window.matchMedia ? window.matchMedia(mobileQuery) : null;&#10;    const applyHeaderBottomClass = () =&gt; {&#10;      if (!mq) return;&#10;      if (mq.matches) {&#10;        document.body.classList.add('header-bottom');&#10;      } else {&#10;        document.body.classList.remove('header-bottom');&#10;      }&#10;    };&#10;    if (mq) {&#10;      // initial&#10;      applyHeaderBottomClass();&#10;      // listen for changes&#10;      if (typeof mq.addEventListener === 'function') {&#10;        mq.addEventListener('change', applyHeaderBottomClass);&#10;      } else if (typeof mq.addListener === 'function') {&#10;        mq.addListener(applyHeaderBottomClass);&#10;      }&#10;    }&#10;&#10;    // トースト表示&#10;    on('#liveToastBtn', 'click', () =&gt; {&#10;      const el = document.getElementById('liveToast');&#10;      if (el &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Toast) bootstrap.Toast.getOrCreateInstance(el).show();&#10;    });&#10;&#10;    // モーダル別にバックドロップの色を切替&#10;    const errorModal = document.getElementById('errorModal');&#10;    if (errorModal) errorModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-error');&#10;    });&#10;&#10;    const scrollableModal = document.getElementById('scrollableModal');&#10;    if (scrollableModal) scrollableModal.addEventListener('shown.bs.modal', () =&gt; {&#10;      const b = document.querySelectorAll('.modal-backdrop');&#10;      if (b.length) b[b.length - 1].classList.add('backdrop-select');&#10;    });&#10;&#10;    // Invalidate caches when menus are updated or modal is hidden (optional)&#10;    if (scrollableModal) scrollableModal.addEventListener('hidden.bs.modal', () =&gt; {&#10;      // keep selection, but we could clear selection if desired&#10;    });&#10;&#10;    // モーダル内のアイテム選択で /content をAJAX遷移（失敗時は通常遷移）。fetchWithTimeout を使いタイムアウトをつける&#10;    on('.content-item', 'click', function (e) {&#10;      e.preventDefault();&#10;      const screenName = this.dataset.screenName;&#10;      const clickedMenuName = (this.dataset &amp;&amp; this.dataset.menuName) ? this.dataset.menuName : (selectedSidebarMenu || '');&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; {&#10;          if (!resp.ok) {&#10;            // レスポンスが正常でない場合はフルナビゲーションへフォールバック&#10;            return Promise.reject('network');&#10;          }&#10;          return resp.text();&#10;        })&#10;        .then(responseText =&gt; {&#10;          try {&#10;            const parser = new DOMParser();&#10;            const doc = parser.parseFromString(responseText, 'text/html');&#10;            const newMain = doc.querySelector('main.main-content');&#10;            const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;            if (newMain) {&#10;              const oldMain = document.querySelector('main.main-content');&#10;              if (oldMain) oldMain.replaceWith(newMain);&#10;              const selectedEl = document.getElementById('selectedItemName');&#10;              if (selectedEl) {&#10;                // Prefer the clicked menuName (if available) to show menu name in the header; otherwise use server-provided value&#10;                selectedEl.textContent = clickedMenuName || newSelectedName;&#10;              }&#10;              const modalEl = document.getElementById('scrollableModal');&#10;              if (modalEl &amp;&amp; window.bootstrap &amp;&amp; bootstrap.Modal) {&#10;                const modalInst = bootstrap.Modal.getInstance(modalEl) || bootstrap.Modal.getOrCreateInstance(modalEl);&#10;                modalInst.hide();&#10;              }&#10;              // Load fragment scripts, wait for pwgen elements, then initialize&#10;              (async function () {&#10;                await loadAndRunScriptsFromFragment(newMain);&#10;                try {&#10;                  // call init immediately and schedule retries to catch late DOM insertion&#10;                  try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                  setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;                } catch (err) { /* initPwgen failed (silently) */ }&#10;              })();&#10;              // Keep menuName in history state so popstate can restore header label correctly&#10;              history.pushState({ screenName, menuName: clickedMenuName }, '', url.toString());&#10;               return;&#10;            }&#10;          } catch (err) {&#10;            // パース失敗時はフル遷移&#10;          }&#10;          window.location.href = url.toString();&#10;        })&#10;        .catch(() =&gt; {&#10;          window.location.href = url.toString();&#10;        });&#10;    });&#10;&#10;    // 戻る/進むで main コンテンツを再取得&#10;    window.addEventListener('popstate', function (event) {&#10;      const state = event.state || {};&#10;      const screenName = state.screenName || null;&#10;      const stateMenuName = state.menuName || null;&#10;      if (!screenName) return;&#10;      const url = new URL(window.location.href);&#10;      url.pathname = '/content';&#10;      url.searchParams.set('screenName', screenName);&#10;      fetchWithTimeout(url.toString(), { credentials: 'same-origin' }, 10000)&#10;        .then(resp =&gt; resp.text())&#10;        .then(responseText =&gt; {&#10;          const parser = new DOMParser();&#10;          const doc = parser.parseFromString(responseText, 'text/html');&#10;          const newMain = doc.querySelector('main.main-content');&#10;          const newSelectedName = (doc.querySelector('#selectedItemName') || {}).textContent || screenName;&#10;          if (newMain) {&#10;            const oldMain = document.querySelector('main.main-content');&#10;            if (oldMain) oldMain.replaceWith(newMain);&#10;            const selectedEl = document.getElementById('selectedItemName');&#10;            if (selectedEl) selectedEl.textContent = (stateMenuName || newSelectedName);&#10;            // Load fragment scripts, wait for pwgen elements, then initialize&#10;            (async function () {&#10;              await loadAndRunScriptsFromFragment(newMain);&#10;              try {&#10;                try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {}&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 120);&#10;                setTimeout(() =&gt; { try { if (typeof initPwgen === 'function') initPwgen(); } catch (_) {} }, 350);&#10;              } catch (err) { /* initPwgen failed (silently) */ }&#10;            })();&#10;          }&#10;        })&#10;        .catch(() =&gt; {});&#10;    });&#10;&#10;    // helper: load scripts found inside a fragment (execute inline scripts, load external ones)&#10;    function loadAndRunScriptsFromFragment(fragmentRoot) {&#10;      try {&#10;        const scripts = Array.from(fragmentRoot.querySelectorAll('script'));&#10;        const loads = [];&#10;        scripts.forEach(s =&gt; {&#10;          const src = s.getAttribute('src');&#10;          if (src) {&#10;            // resolve absolute URL (browser will handle relative)&#10;            const abs = src;&#10;            // skip if already present&#10;            if (!document.querySelector('script[src=&quot;' + abs + '&quot;]')) {&#10;              loads.push(new Promise((res) =&gt; {&#10;                const sc = document.createElement('script');&#10;                sc.src = abs;&#10;                sc.async = false; // preserve execution order&#10;                sc.onload = () =&gt; res();&#10;                sc.onerror = () =&gt; { /* failed to load script (silently) */ res(); };&#10;                document.head.appendChild(sc);&#10;              }));&#10;            }&#10;          } else {&#10;            // inline script: execute by creating a new script element&#10;            try {&#10;              const inline = document.createElement('script');&#10;              inline.text = s.textContent || s.innerText || '';&#10;              document.head.appendChild(inline);&#10;              // no need to wait&#10;            } catch (e) { /* ignore */ }&#10;          }&#10;        });&#10;        return Promise.all(loads);&#10;      } catch (e) {&#10;        return Promise.resolve();&#10;      }&#10;    }&#10;&#10;&#10;  });&#10;&#10;})();&#10;&#10;// End of main.js&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>