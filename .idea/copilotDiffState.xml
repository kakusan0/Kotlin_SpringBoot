<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/config/UndertowWebSocketConfig.kt" />
              <option name="originalContent" value="package com.example.demo.config&#10;&#10;import io.undertow.server.DefaultByteBufferPool&#10;import io.undertow.websockets.jsr.WebSocketDeploymentInfo&#10;import org.springframework.boot.web.embedded.undertow.UndertowDeploymentInfoCustomizer&#10;import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory&#10;import org.springframework.context.annotation.Bean&#10;import org.springframework.context.annotation.Configuration&#10;import org.springframework.core.env.Environment&#10;import org.springframework.util.unit.DataSize&#10;&#10;@Configuration&#10;class UndertowWebSocketConfig(&#10;    private val env: Environment&#10;) {&#10;&#10;    @Bean&#10;    fun undertowServletWebServerFactory(): UndertowServletWebServerFactory {&#10;        val factory = UndertowServletWebServerFactory()&#10;&#10;        val customizer = UndertowDeploymentInfoCustomizer { di -&gt;&#10;            // Undertow の WebSocket 用バッファプールを設定（警告 UT026010 の解消）&#10;            val direct = true // 直接バッファ（GC 負荷軽減）&#10;            val dataSize: DataSize = env.getProperty(&#10;                &quot;server.undertow.buffer-size&quot;,&#10;                DataSize::class.java,&#10;                DataSize.ofKilobytes(16)&#10;            )&#10;            val bufferSize: Int = dataSize.toBytes().coerceAtMost(Int.MAX_VALUE.toLong()).toInt()&#10;            val wsInfo = WebSocketDeploymentInfo()&#10;            wsInfo.buffers = DefaultByteBufferPool(direct, bufferSize)&#10;            (di as io.undertow.servlet.api.DeploymentInfo)&#10;                .addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, wsInfo)&#10;        }&#10;&#10;        factory.setDeploymentInfoCustomizers(listOf(customizer))&#10;        return factory&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo.config&#13;&#10;&#13;&#10;import org.springframework.context.annotation.Configuration&#13;&#10;&#13;&#10;@Configuration&#13;&#10;class UndertowWebSocketConfig {&#13;&#10;    // Undertow を削除したため本クラスは空のプレースホルダです。&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/demo/service/ContentItemService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/demo/service/ContentItemService.kt" />
              <option name="originalContent" value="package com.example.demo.service&#10;&#10;import com.example.demo.mapper.ContentItemMapper&#10;import com.example.demo.model.ContentItem&#10;import org.springframework.cache.annotation.CacheEvict&#10;import org.springframework.cache.annotation.Cacheable&#10;import org.springframework.cache.annotation.Caching&#10;import org.springframework.stereotype.Service&#10;&#10;@Service&#10;class ContentItemService(&#10;    private val contentItemMapper: ContentItemMapper&#10;) {&#10;    // 画面一覧は頻繁に参照されるためキャッシュ&#10;    @Cacheable(cacheNames = [&quot;contentItems&quot;]) // 引数なし: SimpleKey.EMPTY がキー&#10;    fun getAll(): List&lt;ContentItem&gt; = contentItemMapper.selectAll()&#10;&#10;    // 追加: menuName でフィルタした一覧取得&#10;    // Mapper 側の selectByMenuName が環境によって未解決になることがあるため、安全のため selectAll をフィルタして返す実装にする&#10;    fun getByMenuName(menuName: String): List&lt;ContentItem&gt; = contentItemMapper.selectAll().filter { it.menuName == menuName }&#10;&#10;    private fun normalizePathName(record: ContentItem) {&#10;        record.pathName = record.pathName?.trim()?.takeIf { it.isNotEmpty() }&#10;    }&#10;&#10;    @Caching(&#10;        evict = [&#10;            CacheEvict(cacheNames = [&quot;contentItems&quot;], allEntries = true),&#10;            CacheEvict(cacheNames = [&quot;contentItemById&quot;], key = &quot;#record.id&quot;, condition = &quot;#record.id != null&quot;)&#10;        ]&#10;    )&#10;    fun insert(record: ContentItem): Int {&#10;        normalizePathName(record)&#10;        return contentItemMapper.insert(record)&#10;    }&#10;&#10;    @Caching(&#10;        evict = [&#10;            CacheEvict(cacheNames = [&quot;contentItems&quot;], allEntries = true),&#10;            CacheEvict(cacheNames = [&quot;contentItemById&quot;], key = &quot;#record.id&quot;, condition = &quot;#record.id != null&quot;)&#10;        ]&#10;    )&#10;    fun update(record: ContentItem): Int {&#10;        normalizePathName(record)&#10;        return contentItemMapper.updateByPrimaryKey(record)&#10;    }&#10;&#10;    @Caching(&#10;        evict = [&#10;            CacheEvict(cacheNames = [&quot;contentItems&quot;], allEntries = true),&#10;            CacheEvict(cacheNames = [&quot;contentItemById&quot;], key = &quot;#id&quot;)&#10;        ]&#10;    )&#10;    fun delete(id: Long): Int = contentItemMapper.deleteByPrimaryKey(id)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.demo.service&#10;&#10;import com.example.demo.mapper.ContentItemMapper&#10;import com.example.demo.model.ContentItem&#10;import org.springframework.cache.annotation.CacheEvict&#10;import org.springframework.cache.annotation.Cacheable&#10;import org.springframework.cache.annotation.Caching&#10;import org.springframework.stereotype.Service&#10;&#10;@Service&#10;class ContentItemService(&#10;    private val contentItemMapper: ContentItemMapper&#10;) {&#10;    // 画面一覧は頻繁に参照されるためキャッシュ&#10;    @Cacheable(cacheNames = [&quot;contentItems&quot;]) // 引数なし: SimpleKey.EMPTY がキー&#10;    fun getAll(): List&lt;ContentItem&gt; = contentItemMapper.selectAll()&#10;&#10;    // 追加: menuName でフィルタした一覧取得&#10;    // Mapper 側に selectByMenuName があるため、DB側で絞る方が効率的&#10;    @Cacheable(cacheNames = [&quot;contentItemsByMenu&quot;], key = &quot;#menuName&quot;)&#10;    fun getByMenuName(menuName: String): List&lt;ContentItem&gt; = contentItemMapper.selectByMenuName(menuName)&#10;&#10;    private fun normalizePathName(record: ContentItem) {&#10;        record.pathName = record.pathName?.trim()?.takeIf { it.isNotEmpty() }&#10;    }&#10;&#10;    @Caching(&#10;        evict = [&#10;            CacheEvict(cacheNames = [&quot;contentItems&quot;], allEntries = true),&#10;            CacheEvict(cacheNames = [&quot;contentItemById&quot;], key = &quot;#record.id&quot;, condition = &quot;#record.id != null&quot;)&#10;        ]&#10;    )&#10;    fun insert(record: ContentItem): Int {&#10;        normalizePathName(record)&#10;        return contentItemMapper.insert(record)&#10;    }&#10;&#10;    @Caching(&#10;        evict = [&#10;            CacheEvict(cacheNames = [&quot;contentItems&quot;], allEntries = true),&#10;            CacheEvict(cacheNames = [&quot;contentItemById&quot;], key = &quot;#record.id&quot;, condition = &quot;#record.id != null&quot;)&#10;        ]&#10;    )&#10;    fun update(record: ContentItem): Int {&#10;        normalizePathName(record)&#10;        return contentItemMapper.updateByPrimaryKey(record)&#10;    }&#10;&#10;    @Caching(&#10;        evict = [&#10;            CacheEvict(cacheNames = [&quot;contentItems&quot;], allEntries = true),&#10;            CacheEvict(cacheNames = [&quot;contentItemById&quot;], key = &quot;#id&quot;)&#10;        ]&#10;    )&#10;    fun delete(id: Long): Int = contentItemMapper.deleteByPrimaryKey(id)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/static/js/manage.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/static/js/manage.js" />
              <option name="originalContent" value="// 管理画面用クライアントスクリプト（manage.js）&#10;// - 役割: コンテンツ項目とメニューの一覧取得、追加・編集・削除を行う&#10;// - 非同期通信は fetch を使用し、簡易なプロンプトUIで動作します&#10;// - エラー時はユーザーへ alert を表示してフォールバックします&#10;&#10;// Simple manage.js: fetch list of content items and provide add/edit/delete using prompt dialogs&#10;(function () {&#10;  'use strict';&#10;&#10;  // API エンドポイントの定義&#10;  const apiContent = '/api/content';&#10;  const apiMenus = '/api/menus';&#10;  const apiPaths = '/api/paths';&#10;&#10;  // DOM ヘルパ関数&#10;  function qs(sel) { return document.querySelector(sel); }&#10;  function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }&#10;&#10;  // キャッシュ: メニュー一覧を保持して選択肢を高速に構築&#10;  let menusCache = [];&#10;  // キャッシュ: パス一覧（有効のみ）を保持&#10;  // 削除（無効）含む全件を保持し、UIで disabled 表示を行う&#10;  let pathsCache = [];&#10;&#10;  // BroadcastChannel を使って同一ブラウザ内のタブ間で更新を通知する&#10;  const menusBroadcast = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('menus-channel') : null;&#10;&#10;  // --- レンダリング用関数 ---&#10;  // テーブル行を作成するユーティリティ&#10;  function renderMenuRow(menu) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = menu.id || '';&#10;    const nameTd = document.createElement('td'); nameTd.textContent = menu.name || '';&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditMenu(menu));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteMenu(menu));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // パス管理用テーブル行を作成するユーティリティ&#10;  function renderPathRow(path) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = path.id || '';&#10;    const nameTd = document.createElement('td'); nameTd.textContent = path.name || '';&#10;    const statusTd = document.createElement('td');&#10;    const actionsTd = document.createElement('td');&#10;&#10;    // 状態プルダウン（有効/無効）&#10;    const statusSelect = document.createElement('select');&#10;    statusSelect.className = 'form-select form-select-sm';&#10;    const optEnabled = document.createElement('option'); optEnabled.value = 'enabled'; optEnabled.textContent = '有効';&#10;    const optDisabled = document.createElement('option'); optDisabled.value = 'disabled'; optDisabled.textContent = '無効';&#10;    statusSelect.appendChild(optEnabled);&#10;    statusSelect.appendChild(optDisabled);&#10;    statusSelect.value = (path.deleted ? 'disabled' : 'enabled');&#10;    statusSelect.addEventListener('change', async () =&gt; {&#10;      const willDisable = statusSelect.value === 'disabled';&#10;      await onChangePathStatus(path, willDisable, statusSelect);&#10;    });&#10;    statusTd.appendChild(statusSelect);&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary';&#10;    editBtn.textContent = '名称編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditPath(path));&#10;    actionsTd.appendChild(editBtn);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(statusTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // セレクト要素を作成して現在値を反映する&#10;  function buildMenuSelect(currentValue, item) {&#10;    const select = document.createElement('select');&#10;    select.className = 'form-select form-select-sm menu-select';&#10;    // for debugging/tracking&#10;    if (item &amp;&amp; item.id) select.setAttribute('data-item-id', item.id);&#10;&#10;    // ensure currentValue is represented even if it's not in menusCache&#10;    const hasCurrent = menusCache.some(m =&gt; m.name === currentValue);&#10;&#10;    // empty option&#10;    const emptyOpt = document.createElement('option');&#10;    emptyOpt.value = '';&#10;    emptyOpt.textContent = '未選択';&#10;    select.appendChild(emptyOpt);&#10;&#10;    // add known menus&#10;    menusCache.forEach(m =&gt; {&#10;      const opt = document.createElement('option');&#10;      opt.value = m.name;&#10;      opt.textContent = m.name;&#10;      select.appendChild(opt);&#10;    });&#10;&#10;    // if current value missing from menusCache, add it so the select shows it&#10;    if (currentValue &amp;&amp; !hasCurrent) {&#10;      const opt = document.createElement('option');&#10;      opt.value = currentValue;&#10;      opt.textContent = currentValue + ' (削除済み)';&#10;      // insert after empty option&#10;      select.insertBefore(opt, select.children[1] || null);&#10;    }&#10;&#10;    select.value = currentValue || '';&#10;&#10;    // handle change&#10;    select.addEventListener('change', async function (ev) {&#10;      const newVal = ev.target.value || null;&#10;      await onChangeMenuForItem(item, newVal, ev.target);&#10;    });&#10;&#10;    return select;&#10;  }&#10;&#10;  // パス名用のセレクトを構築&#10;  function buildPathSelect(currentValue, item) {&#10;    const select = document.createElement('select');&#10;    select.className = 'form-select form-select-sm path-select';&#10;    if (item &amp;&amp; item.id) select.setAttribute('data-item-id', item.id);&#10;&#10;    const hasCurrent = pathsCache.some(p =&gt; p.name === currentValue);&#10;&#10;    // 空（未選択）&#10;    const emptyOpt = document.createElement('option');&#10;    emptyOpt.value = '';&#10;    emptyOpt.textContent = '未選択';&#10;    select.appendChild(emptyOpt);&#10;&#10;    // 有効/無効を含む全パス（無効は選択不可）&#10;    pathsCache.forEach(p =&gt; {&#10;      const opt = document.createElement('option');&#10;      opt.value = p.name;&#10;      opt.textContent = p.name + (p.deleted ? '（無効）' : '');&#10;      if (p.deleted) opt.disabled = true;&#10;      select.appendChild(opt);&#10;    });&#10;&#10;    // 現在値が（削除等で）有効リストにない場合は表示用に追加&#10;    if (currentValue &amp;&amp; !hasCurrent) {&#10;      const opt = document.createElement('option');&#10;      opt.value = currentValue;&#10;      opt.textContent = currentValue + '（無効）';&#10;      opt.disabled = true;&#10;      select.insertBefore(opt, select.children[1] || null);&#10;    }&#10;&#10;    select.value = currentValue || '';&#10;&#10;    // 変更ハンドラ&#10;    select.addEventListener('change', async function (ev) {&#10;      const newVal = ev.target.value || null;&#10;      await onChangePathForItem(item, newVal, ev.target);&#10;    });&#10;&#10;    return select;&#10;  }&#10;&#10;  // 画面名用の入力欄を構築（インライン編集）&#10;  function buildItemNameInput(currentValue, item) {&#10;    const input = document.createElement('input');&#10;    input.type = 'text';&#10;    input.className = 'form-control form-control-sm name-input';&#10;    if (item &amp;&amp; item.id) input.setAttribute('data-item-id', item.id);&#10;    input.value = currentValue || '';&#10;&#10;    let prev = input.value;&#10;&#10;    const commit = async () =&gt; {&#10;      const newVal = (input.value != null) ? String(input.value).trim() : '';&#10;      if (newVal === prev) return; // no change&#10;      await onChangeItemName(item, newVal, input);&#10;      // on success, prev is updated inside handler&#10;    };&#10;&#10;    input.addEventListener('change', commit);&#10;    input.addEventListener('blur', commit);&#10;    input.addEventListener('keydown', function (ev) {&#10;      if (ev.key === 'Enter') {&#10;        ev.preventDefault();&#10;        input.blur(); // triggers commit&#10;      } else if (ev.key === 'Escape') {&#10;        ev.preventDefault();&#10;        try { input.value = prev || ''; } catch (_) {}&#10;        input.blur();&#10;      }&#10;    });&#10;&#10;    // 外部から元値を更新できるようにヘルパ保管&#10;    input.__getPrev = () =&gt; prev;&#10;    input.__setPrev = (v) =&gt; { prev = v; };&#10;&#10;    return input;&#10;  }&#10;&#10;  // 画面項目の行レンダリング&#10;  function renderScreenRow(item) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = item.id || '';&#10;    const menuTd = document.createElement('td');&#10;    const nameTd = document.createElement('td');&#10;    const pathTd = document.createElement('td');&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditScreen(item));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteScreen(item));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    // create select for menu name&#10;    const select = buildMenuSelect(item.menuName, item);&#10;    menuTd.appendChild(select);&#10;&#10;    // create input for item name (inline editable)&#10;    const nameInput = buildItemNameInput(item.itemName, item);&#10;    nameTd.appendChild(nameInput);&#10;&#10;    // create select for pathName sourced from path master&#10;    const pathSelect = buildPathSelect(item.pathName, item);&#10;    pathTd.appendChild(pathSelect);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(menuTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(pathTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // --- ヘルパ ---&#10;  // メニューキャッシュが更新された際に、既存のセレクト要素を再構築する&#10;  function refreshMenuSelects() {&#10;    const selects = qsa('.menu-select');&#10;    selects.forEach(sel =&gt; {&#10;      const currentVal = sel.value || '';&#10;      // try to preserve selection&#10;      // rebuild options&#10;      while (sel.firstChild) sel.removeChild(sel.firstChild);&#10;&#10;      const emptyOpt = document.createElement('option');&#10;      emptyOpt.value = '';&#10;      emptyOpt.textContent = '未選択';&#10;      sel.appendChild(emptyOpt);&#10;      menusCache.forEach(m =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = m.name;&#10;        opt.textContent = m.name;&#10;        sel.appendChild(opt);&#10;      });&#10;      if (currentVal &amp;&amp; !menusCache.some(m =&gt; m.name === currentVal)) {&#10;        const opt = document.createElement('option');&#10;        opt.value = currentVal;&#10;        opt.textContent = currentVal + ' (削除済み)';&#10;        sel.insertBefore(opt, sel.children[1] || null);&#10;      }&#10;      sel.value = currentVal;&#10;    });&#10;  }&#10;&#10;  // パスキャッシュが更新された際に、既存のパスセレクトを再構築&#10;  function refreshPathSelects() {&#10;    const selects = qsa('.path-select');&#10;    selects.forEach(sel =&gt; {&#10;      const currentVal = sel.value || '';&#10;      while (sel.firstChild) sel.removeChild(sel.firstChild);&#10;      const emptyOpt = document.createElement('option');&#10;      emptyOpt.value = '';&#10;      emptyOpt.textContent = '未選択';&#10;      sel.appendChild(emptyOpt);&#10;      pathsCache.forEach(p =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = p.name;&#10;        opt.textContent = p.name + (p.deleted ? '（無効）' : '');&#10;        if (p.deleted) opt.disabled = true;&#10;        sel.appendChild(opt);&#10;      });&#10;      if (currentVal &amp;&amp; !pathsCache.some(p =&gt; p.name === currentVal)) {&#10;        const opt = document.createElement('option');&#10;        opt.value = currentVal;&#10;        opt.textContent = currentVal + '（無効）';&#10;        opt.disabled = true;&#10;        sel.insertBefore(opt, sel.children[1] || null);&#10;      }&#10;      sel.value = currentVal;&#10;    });&#10;  }&#10;&#10;  // 内容のメニュー変更をサーバへ送信するハンドラ&#10;  async function onChangeMenuForItem(item, newMenuName, selectElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.menuName || null;&#10;    if (newMenuName === prev) return; // nothing to do&#10;&#10;    const payload = Object.assign({}, item, { menuName: newMenuName });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        // サーバエラー: ユーザーへ通知して選択を元に戻す&#10;        alert('メニューの更新に失敗しました');&#10;        try { selectElem.value = prev || ''; } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.menuName = newMenuName;&#10;      // optional: show tiny feedback (could be improved)&#10;      // e.g., briefly flash background&#10;      selectElem.classList.add('is-valid');&#10;      setTimeout(() =&gt; selectElem.classList.remove('is-valid'), 800);&#10;    } catch (e) {&#10;      alert('メニューの更新に失敗しました');&#10;      // revert selection&#10;      try { selectElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // 内容のパス名変更をサーバへ送信するハンドラ&#10;  async function onChangePathForItem(item, newPathName, inputElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.pathName || null;&#10;    // normalize empty string to null&#10;    const normalized = (newPathName == null || newPathName === '') ? null : String(newPathName).trim();&#10;    if (normalized === prev) return; // nothing to do&#10;&#10;    const payload = Object.assign({}, item, { pathName: normalized });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('パス名の更新に失敗しました');&#10;        try { if (inputElem) inputElem.value = prev || ''; if (inputElem) inputElem.classList.add('is-invalid'); } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.pathName = normalized;&#10;      if (inputElem) {&#10;        inputElem.classList.add('is-valid');&#10;        setTimeout(() =&gt; inputElem.classList.remove('is-valid'), 800);&#10;      }&#10;    } catch (e) {&#10;      alert('パス名の更新に失敗しました');&#10;      try { if (inputElem) inputElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // 画面名変更をサーバへ送信するハンドラ（インライン）&#10;  async function onChangeItemName(item, newName, inputElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.itemName || '';&#10;    // newName は空文字も許容（サーバ側に任せる）。正規化: trim のみ&#10;    const normalized = (newName == null) ? '' : String(newName).trim();&#10;    if (normalized === prev) return;&#10;&#10;    const payload = Object.assign({}, item, { itemName: normalized });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('画面名の更新に失敗しました');&#10;        try {&#10;          if (inputElem) {&#10;            inputElem.value = prev || '';&#10;            inputElem.classList.add('is-invalid');&#10;            setTimeout(() =&gt; inputElem.classList.remove('is-invalid'), 1000);&#10;          }&#10;        } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.itemName = normalized;&#10;      if (inputElem) {&#10;        if (typeof inputElem.__setPrev === 'function') inputElem.__setPrev(normalized);&#10;        inputElem.classList.add('is-valid');&#10;        setTimeout(() =&gt; inputElem.classList.remove('is-valid'), 800);&#10;      }&#10;    } catch (e) {&#10;      alert('画面名の更新に失敗しました');&#10;      try { if (inputElem) inputElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // パスの状態変更（有効/無効）をPUT更新&#10;  async function onChangePathStatus(path, willDisable, selectElem) {&#10;    const prev = !!path.deleted;&#10;    if (prev === willDisable) return;&#10;    const payload = Object.assign({}, path, { deleted: willDisable });&#10;    try {&#10;      const resp = await fetch(apiPaths, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('状態の更新に失敗しました');&#10;        try { selectElem.value = prev ? 'disabled' : 'enabled'; } catch(_){}&#10;        return;&#10;      }&#10;      path.deleted = willDisable;&#10;      // パスの有効/無効に応じて画面管理のプルダウンを更新&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('状態の更新に失敗しました');&#10;      try { selectElem.value = prev ? 'disabled' : 'enabled'; } catch(_){}&#10;    }&#10;  }&#10;&#10;  // --- データロード ---&#10;  // パス一覧（有効のみ）を読み込みテーブルを更新&#10;  async function loadPaths() {&#10;    const tbody = qs('#pathTable tbody');&#10;    // パス管理タブ用テーブルがないページではスキップ&#10;    const isPathsPage = !!tbody;&#10;    if (isPathsPage) tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      // 削除（無効）含む一覧を1回で取得し、キャッシュ・UI双方で利用&#10;      const resp = await fetch(apiPaths + '/allIncludingDeleted');&#10;      if (!resp.ok) {&#10;        if (isPathsPage) tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        pathsCache = [];&#10;        refreshPathSelects();&#10;        return [];&#10;      }&#10;      const all = await resp.json();&#10;      pathsCache = all || [];&#10;      refreshPathSelects();&#10;      tbody.innerHTML = '';&#10;      if (!all || !all.length) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;パスがありません&lt;/td&gt;&lt;/tr&gt;';&#10;        return pathsCache;&#10;      }&#10;      all.forEach(p =&gt; tbody.appendChild(renderPathRow(p)));&#10;      return pathsCache;&#10;    } catch (e) {&#10;      if (isPathsPage) tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      pathsCache = [];&#10;      refreshPathSelects();&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // メニュー一覧を読み込みテーブルを更新&#10;  async function loadMenus() {&#10;    const tbody = qs('#menuTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      const resp = await fetch(apiMenus + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const menus = await resp.json();&#10;      menusCache = menus || [];&#10;      tbody.innerHTML = '';&#10;      if (!menusCache || !menusCache.length) {&#10;        // If there are no menus defined in menu management, try to show menuNames derived from screens&#10;        // This avoids confusing mismatch where home shows menus (from screens) but admin shows none.&#10;        // Load screens and extract unique menuName values.&#10;        try {&#10;          const r = await fetch(apiContent + '/all');&#10;          if (!r.ok) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          const items = await r.json();&#10;          const menuNames = Array.from(new Set((items || []).map(it =&gt; it.menuName).filter(Boolean)));&#10;          if (!menuNames.length) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          // Render derived menu rows with a note and an import button&#10;          menuNames.forEach((name) =&gt; {&#10;            const tr = document.createElement('tr');&#10;            const idTd = document.createElement('td'); idTd.textContent = '';&#10;            const nameTd = document.createElement('td'); nameTd.textContent = name + ' (画面管理由来)';&#10;            const actionsTd = document.createElement('td');&#10;&#10;            const importBtn = document.createElement('button');&#10;            importBtn.className = 'btn btn-sm btn-outline-success me-2';&#10;            importBtn.textContent = 'インポート';&#10;            importBtn.addEventListener('click', async () =&gt; {&#10;              // create menu via API&#10;              try {&#10;                const resp2 = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });&#10;                if (!resp2.ok) {&#10;                  alert('インポートに失敗しました');&#10;                  return;&#10;                }&#10;                // reload official menus&#10;                await loadMenus();&#10;                await loadScreens();&#10;              } catch (e) {&#10;                alert('インポートに失敗しました');&#10;              }&#10;            });&#10;&#10;            actionsTd.appendChild(importBtn);&#10;            tr.appendChild(idTd);&#10;            tr.appendChild(nameTd);&#10;            tr.appendChild(actionsTd);&#10;            tbody.appendChild(tr);&#10;          });&#10;          // ensure selects are refreshed&#10;          refreshMenuSelects();&#10;          return menuNames;&#10;        } catch (e) {&#10;          tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;          // still refresh selects to show empty options&#10;          refreshMenuSelects();&#10;          return [];&#10;        }&#10;      }&#10;      menusCache.forEach(m =&gt; tbody.appendChild(renderMenuRow(m)));&#10;      // update any existing select elements in screens&#10;      refreshMenuSelects();&#10;      return menusCache;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // 画面項目一覧を読み込みテーブルを更新&#10;  async function loadScreens() {&#10;    const tbody = qs('#manageTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      // ensure menusCache is populated so selects can be built properly&#10;      if (!menusCache || !menusCache.length) {&#10;        await loadMenus();&#10;      }&#10;      // ensure pathsCache is populated so path selects can be built properly&#10;      if (!pathsCache || !pathsCache.length) {&#10;        await loadPaths();&#10;      }&#10;      const resp = await fetch(apiContent + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const items = await resp.json();&#10;      tbody.innerHTML = '';&#10;      if (!items || !items.length) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;項目がありません&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      items.forEach(it =&gt; tbody.appendChild(renderScreenRow(it)));&#10;      return items;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // --- メニュー操作 ---&#10;  // 追加・編集・削除の各操作（ユーザー確認/プロンプトを含む）&#10;  async function onAddMenu() {&#10;    const name = window.prompt('追加するメニュー名を入力してください', '新しいメニュー');&#10;    if (!name) return;&#10;    const payload = { name };&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('メニュー作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      // refresh menu dropdowns for adding screens&#10;      await loadScreens();&#10;      // notify other tabs/pages to refresh sidebar menus&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('メニュー作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditMenu(menu) {&#10;    const name = window.prompt('メニュー名を編集してください', menu.name || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, menu, { name });&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteMenu(menu) {&#10;    if (!window.confirm('このメニューを削除してよいですか?（メニューに紐づく画面がある場合、連鎖的な整合性は考慮していません）')) return;&#10;    try {&#10;      const resp = await fetch(apiMenus + '/' + menu.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // --- パス操作 ---&#10;  async function onAddPath() {&#10;    const name = window.prompt('追加するパス名を入力してください（例: passwordGeneration）', '');&#10;    if (!name) return;&#10;    const payload = { name };&#10;    try {&#10;      const resp = await fetch(apiPaths, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) { alert('パス作成に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('パス作成に失敗しました'); }&#10;  }&#10;&#10;  async function onEditPath(path) {&#10;    const name = window.prompt('パス名を編集してください', path.name || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, path, { name });&#10;    try {&#10;      const resp = await fetch(apiPaths, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) { alert('更新に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('更新に失敗しました'); }&#10;  }&#10;&#10;  async function onDeletePath(path) {&#10;    if (!window.confirm('このパスを論理削除します。よろしいですか？')) return;&#10;    try {&#10;      const resp = await fetch(apiPaths + '/' + path.id, { method: 'DELETE' });&#10;      if (!resp.ok) { alert('削除に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('削除に失敗しました'); }&#10;  }&#10;&#10;  async function onRestorePath(path) {&#10;    try {&#10;      const resp = await fetch(apiPaths + '/' + path.id + '/restore', { method: 'POST' });&#10;      if (!resp.ok) { alert('復元に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('復元に失敗しました'); }&#10;  }&#10;&#10;  // --- 画面項目操作 ---&#10;  async function onAddScreen() {&#10;    const name = window.prompt('追加する画面名を入力してください', '新しい画面');&#10;    if (!name) return;&#10;    // choose menu from existing&#10;    const menus = await loadMenus();&#10;    if (!menus || !menus.length) {&#10;      alert('先にメニューを追加してください');&#10;      return;&#10;    }&#10;    // build selection prompt&#10;    let list = 'メニューを選んで番号を入力してください:\n';&#10;    menus.forEach((m, idx) =&gt; { list += `${idx + 1}: ${m.name}\n`; });&#10;    const sel = window.prompt(list, '1');&#10;    if (!sel) return;&#10;    const idx = parseInt(sel) - 1;&#10;    if (isNaN(idx) || idx &lt; 0 || idx &gt;= menus.length) { alert('不正な選択'); return; }&#10;    const menuName = menus[idx].name;&#10;    // optional pathName input&#10;    const pathName = window.prompt('この画面のパス名を入力してください（例: passwordGeneration）。空欄でも可', '');&#10;    const payload = { itemName: name, menuName, pathName: (pathName ? pathName.trim() : null) };&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditScreen(item) {&#10;    // Per requirement, menuName is editable via select — here only itemName editable&#10;    const name = window.prompt('画面名を編集してください', item.itemName || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, item, { itemName: name });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteScreen(item) {&#10;    if (!window.confirm('削除してよいですか?')) return;&#10;    try {&#10;      const resp = await fetch(apiContent + '/' + item.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // 初期化: イベントリスナ登録とデータロード&#10;  function initManagePage() {&#10;    try {&#10;      const addMenuBtn = qs('#addMenuBtn');&#10;      if (addMenuBtn &amp;&amp; !addMenuBtn.__bound) {&#10;        addMenuBtn.addEventListener('click', onAddMenu);&#10;        addMenuBtn.__bound = true;&#10;      }&#10;      const addScreenBtn = qs('#addScreenBtn');&#10;      if (addScreenBtn &amp;&amp; !addScreenBtn.__bound) {&#10;        addScreenBtn.addEventListener('click', onAddScreen);&#10;        addScreenBtn.__bound = true;&#10;      }&#10;      const addPathBtn = qs('#addPathBtn');&#10;      if (addPathBtn &amp;&amp; !addPathBtn.__bound) {&#10;        addPathBtn.addEventListener('click', onAddPath);&#10;        addPathBtn.__bound = true;&#10;      }&#10;      // 初回ロード順序&#10;      loadMenus().then(() =&gt; loadPaths()).then(() =&gt; loadScreens());&#10;    } catch (_) { /* ignore */ }&#10;  }&#10;&#10;  // DOMContentLoaded で初期化&#10;  document.addEventListener('DOMContentLoaded', initManagePage);&#10;  // 既に読み込み済みなら即時初期化（フォールバック）&#10;  if (document.readyState === 'interactive' || document.readyState === 'complete') {&#10;    // 少し遅延してDOM構築完了を待つ&#10;    setTimeout(initManagePage, 0);&#10;  }&#10;&#10;})();&#10;" />
              <option name="updatedContent" value="// 管理画面用クライアントスクリプト（manage.js）&#10;// - 役割: コンテンツ項目とメニューの一覧取得、追加・編集・削除を行う&#10;// - 非同期通信は fetch を使用し、簡易なプロンプトUIで動作します&#10;// - エラー時はユーザーへ alert を表示してフォールバックします&#10;&#10;// Simple manage.js: fetch list of content items and provide add/edit/delete using prompt dialogs&#10;(function () {&#10;  'use strict';&#10;&#10;  // API エンドポイントの定義&#10;  const apiContent = '/api/content';&#10;  const apiMenus = '/api/menus';&#10;  const apiPaths = '/api/paths';&#10;&#10;  // DOM ヘルパ関数&#10;  function qs(sel) { return document.querySelector(sel); }&#10;  function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }&#10;&#10;  // キャッシュ: メニュー一覧を保持して選択肢を高速に構築&#10;  let menusCache = [];&#10;  // キャッシュ: パス一覧（有効のみ）を保持&#10;  // 削除（無効）含む全件を保持し、UIで disabled 表示を行う&#10;  let pathsCache = [];&#10;&#10;  // BroadcastChannel を使って同一ブラウザ内のタブ間で更新を通知する&#10;  const menusBroadcast = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('menus-channel') : null;&#10;&#10;  // --- レンダリング用関数 ---&#10;  // テーブル行を作成するユーティリティ&#10;  function renderMenuRow(menu) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = menu.id || '';&#10;    const nameTd = document.createElement('td'); nameTd.textContent = menu.name || '';&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditMenu(menu));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteMenu(menu));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // パス管理用テーブル行を作成するユーティリティ&#10;  function renderPathRow(path) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = path.id || '';&#10;    const nameTd = document.createElement('td'); nameTd.textContent = path.name || '';&#10;    const statusTd = document.createElement('td');&#10;    const actionsTd = document.createElement('td');&#10;&#10;    // 状態プルダウン（有効/無効）&#10;    const statusSelect = document.createElement('select');&#10;    statusSelect.className = 'form-select form-select-sm';&#10;    const optEnabled = document.createElement('option'); optEnabled.value = 'enabled'; optEnabled.textContent = '有効';&#10;    const optDisabled = document.createElement('option'); optDisabled.value = 'disabled'; optDisabled.textContent = '無効';&#10;    statusSelect.appendChild(optEnabled);&#10;    statusSelect.appendChild(optDisabled);&#10;    statusSelect.value = (path.deleted ? 'disabled' : 'enabled');&#10;    statusSelect.addEventListener('change', async () =&gt; {&#10;      const willDisable = statusSelect.value === 'disabled';&#10;      await onChangePathStatus(path, willDisable, statusSelect);&#10;    });&#10;    statusTd.appendChild(statusSelect);&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '名称編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditPath(path));&#10;    actionsTd.appendChild(editBtn);&#10;&#10;    // 削除 / 復元 ボタンを追加&#10;    if (path.deleted) {&#10;      const restoreBtn = document.createElement('button');&#10;      restoreBtn.className = 'btn btn-sm btn-outline-success ms-2';&#10;      restoreBtn.textContent = '復元';&#10;      restoreBtn.addEventListener('click', () =&gt; onRestorePath(path));&#10;      actionsTd.appendChild(restoreBtn);&#10;    } else {&#10;      const delBtn = document.createElement('button');&#10;      delBtn.className = 'btn btn-sm btn-outline-danger ms-2';&#10;      delBtn.textContent = '削除';&#10;      delBtn.addEventListener('click', () =&gt; onDeletePath(path));&#10;      actionsTd.appendChild(delBtn);&#10;    }&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(statusTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // セレクト要素を作成して現在値を反映する&#10;  function buildMenuSelect(currentValue, item) {&#10;    const select = document.createElement('select');&#10;    select.className = 'form-select form-select-sm menu-select';&#10;    // for debugging/tracking&#10;    if (item &amp;&amp; item.id) select.setAttribute('data-item-id', item.id);&#10;&#10;    // ensure currentValue is represented even if it's not in menusCache&#10;    const hasCurrent = menusCache.some(m =&gt; m.name === currentValue);&#10;&#10;    // empty option&#10;    const emptyOpt = document.createElement('option');&#10;    emptyOpt.value = '';&#10;    emptyOpt.textContent = '未選択';&#10;    select.appendChild(emptyOpt);&#10;&#10;    // add known menus&#10;    menusCache.forEach(m =&gt; {&#10;      const opt = document.createElement('option');&#10;      opt.value = m.name;&#10;      opt.textContent = m.name;&#10;      select.appendChild(opt);&#10;    });&#10;&#10;    // if current value missing from menusCache, add it so the select shows it&#10;    if (currentValue &amp;&amp; !hasCurrent) {&#10;      const opt = document.createElement('option');&#10;      opt.value = currentValue;&#10;      opt.textContent = currentValue + ' (削除済み)';&#10;      // insert after empty option&#10;      select.insertBefore(opt, select.children[1] || null);&#10;    }&#10;&#10;    select.value = currentValue || '';&#10;&#10;    // handle change&#10;    select.addEventListener('change', async function (ev) {&#10;      const newVal = ev.target.value || null;&#10;      await onChangeMenuForItem(item, newVal, ev.target);&#10;    });&#10;&#10;    return select;&#10;  }&#10;&#10;  // パス名用のセレクトを構築&#10;  function buildPathSelect(currentValue, item) {&#10;    const select = document.createElement('select');&#10;    select.className = 'form-select form-select-sm path-select';&#10;    if (item &amp;&amp; item.id) select.setAttribute('data-item-id', item.id);&#10;&#10;    const hasCurrent = pathsCache.some(p =&gt; p.name === currentValue);&#10;&#10;    // 空（未選択）&#10;    const emptyOpt = document.createElement('option');&#10;    emptyOpt.value = '';&#10;    emptyOpt.textContent = '未選択';&#10;    select.appendChild(emptyOpt);&#10;&#10;    // 有効/無効を含む全パス（無効は選択不可）&#10;    pathsCache.forEach(p =&gt; {&#10;      const opt = document.createElement('option');&#10;      opt.value = p.name;&#10;      opt.textContent = p.name + (p.deleted ? '（無効）' : '');&#10;      if (p.deleted) opt.disabled = true;&#10;      select.appendChild(opt);&#10;    });&#10;&#10;    // 現在値が（削除等で）有効リストにない場合は表示用に追加&#10;    if (currentValue &amp;&amp; !hasCurrent) {&#10;      const opt = document.createElement('option');&#10;      opt.value = currentValue;&#10;      opt.textContent = currentValue + '（無効）';&#10;      opt.disabled = true;&#10;      select.insertBefore(opt, select.children[1] || null);&#10;    }&#10;&#10;    select.value = currentValue || '';&#10;&#10;    // 変更ハンドラ&#10;    select.addEventListener('change', async function (ev) {&#10;      const newVal = ev.target.value || null;&#10;      await onChangePathForItem(item, newVal, ev.target);&#10;    });&#10;&#10;    return select;&#10;  }&#10;&#10;  // 画面名用の入力欄を構築（インライン編集）&#10;  function buildItemNameInput(currentValue, item) {&#10;    const input = document.createElement('input');&#10;    input.type = 'text';&#10;    input.className = 'form-control form-control-sm name-input';&#10;    if (item &amp;&amp; item.id) input.setAttribute('data-item-id', item.id);&#10;    input.value = currentValue || '';&#10;&#10;    let prev = input.value;&#10;&#10;    const commit = async () =&gt; {&#10;      const newVal = (input.value != null) ? String(input.value).trim() : '';&#10;      if (newVal === prev) return; // no change&#10;      await onChangeItemName(item, newVal, input);&#10;      // on success, prev is updated inside handler&#10;    };&#10;&#10;    input.addEventListener('change', commit);&#10;    input.addEventListener('blur', commit);&#10;    input.addEventListener('keydown', function (ev) {&#10;      if (ev.key === 'Enter') {&#10;        ev.preventDefault();&#10;        input.blur(); // triggers commit&#10;      } else if (ev.key === 'Escape') {&#10;        ev.preventDefault();&#10;        try { input.value = prev || ''; } catch (_) {}&#10;        input.blur();&#10;      }&#10;    });&#10;&#10;    // 外部から元値を更新できるようにヘルパ保管&#10;    input.__getPrev = () =&gt; prev;&#10;    input.__setPrev = (v) =&gt; { prev = v; };&#10;&#10;    return input;&#10;  }&#10;&#10;  // 画面項目の行レンダリング&#10;  function renderScreenRow(item) {&#10;    const tr = document.createElement('tr');&#10;    const idTd = document.createElement('td'); idTd.textContent = item.id || '';&#10;    const menuTd = document.createElement('td');&#10;    const nameTd = document.createElement('td');&#10;    const pathTd = document.createElement('td');&#10;    const actionsTd = document.createElement('td');&#10;&#10;    const editBtn = document.createElement('button');&#10;    editBtn.className = 'btn btn-sm btn-outline-primary me-2';&#10;    editBtn.textContent = '編集';&#10;    editBtn.addEventListener('click', () =&gt; onEditScreen(item));&#10;&#10;    const delBtn = document.createElement('button');&#10;    delBtn.className = 'btn btn-sm btn-outline-danger';&#10;    delBtn.textContent = '削除';&#10;    delBtn.addEventListener('click', () =&gt; onDeleteScreen(item));&#10;&#10;    actionsTd.appendChild(editBtn);&#10;    actionsTd.appendChild(delBtn);&#10;&#10;    // create select for menu name&#10;    const select = buildMenuSelect(item.menuName, item);&#10;    menuTd.appendChild(select);&#10;&#10;    // create input for item name (inline editable)&#10;    const nameInput = buildItemNameInput(item.itemName, item);&#10;    nameTd.appendChild(nameInput);&#10;&#10;    // create select for pathName sourced from path master&#10;    const pathSelect = buildPathSelect(item.pathName, item);&#10;    pathTd.appendChild(pathSelect);&#10;&#10;    tr.appendChild(idTd);&#10;    tr.appendChild(menuTd);&#10;    tr.appendChild(nameTd);&#10;    tr.appendChild(pathTd);&#10;    tr.appendChild(actionsTd);&#10;    return tr;&#10;  }&#10;&#10;  // --- ヘルパ ---&#10;  // メニューキャッシュが更新された際に、既存のセレクト要素を再構築する&#10;  function refreshMenuSelects() {&#10;    const selects = qsa('.menu-select');&#10;    selects.forEach(sel =&gt; {&#10;      const currentVal = sel.value || '';&#10;      // try to preserve selection&#10;      // rebuild options&#10;      while (sel.firstChild) sel.removeChild(sel.firstChild);&#10;&#10;      const emptyOpt = document.createElement('option');&#10;      emptyOpt.value = '';&#10;      emptyOpt.textContent = '未選択';&#10;      sel.appendChild(emptyOpt);&#10;      menusCache.forEach(m =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = m.name;&#10;        opt.textContent = m.name;&#10;        sel.appendChild(opt);&#10;      });&#10;      if (currentVal &amp;&amp; !menusCache.some(m =&gt; m.name === currentVal)) {&#10;        const opt = document.createElement('option');&#10;        opt.value = currentVal;&#10;        opt.textContent = currentVal + ' (削除済み)';&#10;        sel.insertBefore(opt, sel.children[1] || null);&#10;      }&#10;      sel.value = currentVal;&#10;    });&#10;  }&#10;&#10;  // パスキャッシュが更新された際に、既存のパスセレクトを再構築&#10;  function refreshPathSelects() {&#10;    const selects = qsa('.path-select');&#10;    selects.forEach(sel =&gt; {&#10;      const currentVal = sel.value || '';&#10;      while (sel.firstChild) sel.removeChild(sel.firstChild);&#10;      const emptyOpt = document.createElement('option');&#10;      emptyOpt.value = '';&#10;      emptyOpt.textContent = '未選択';&#10;      sel.appendChild(emptyOpt);&#10;      pathsCache.forEach(p =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = p.name;&#10;        opt.textContent = p.name + (p.deleted ? '（無効）' : '');&#10;        if (p.deleted) opt.disabled = true;&#10;        sel.appendChild(opt);&#10;      });&#10;      if (currentVal &amp;&amp; !pathsCache.some(p =&gt; p.name === currentVal)) {&#10;        const opt = document.createElement('option');&#10;        opt.value = currentVal;&#10;        opt.textContent = currentVal + '（無効）';&#10;        opt.disabled = true;&#10;        sel.insertBefore(opt, sel.children[1] || null);&#10;      }&#10;      sel.value = currentVal;&#10;    });&#10;  }&#10;&#10;  // 内容のメニュー変更をサーバへ送信するハンドラ&#10;  async function onChangeMenuForItem(item, newMenuName, selectElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.menuName || null;&#10;    if (newMenuName === prev) return; // nothing to do&#10;&#10;    const payload = Object.assign({}, item, { menuName: newMenuName });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        // サーバエラー: ユーザーへ通知して選択を元に戻す&#10;        alert('メニューの更新に失敗しました');&#10;        try { selectElem.value = prev || ''; } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.menuName = newMenuName;&#10;      // optional: show tiny feedback (could be improved)&#10;      // e.g., briefly flash background&#10;      selectElem.classList.add('is-valid');&#10;      setTimeout(() =&gt; selectElem.classList.remove('is-valid'), 800);&#10;    } catch (e) {&#10;      alert('メニューの更新に失敗しました');&#10;      // revert selection&#10;      try { selectElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // 内容のパス名変更をサーバへ送信するハンドラ&#10;  async function onChangePathForItem(item, newPathName, inputElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.pathName || null;&#10;    // normalize empty string to null&#10;    const normalized = (newPathName == null || newPathName === '') ? null : String(newPathName).trim();&#10;    if (normalized === prev) return; // nothing to do&#10;&#10;    const payload = Object.assign({}, item, { pathName: normalized });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('パス名の更新に失敗しました');&#10;        try { if (inputElem) inputElem.value = prev || ''; if (inputElem) inputElem.classList.add('is-invalid'); } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.pathName = normalized;&#10;      if (inputElem) {&#10;        inputElem.classList.add('is-valid');&#10;        setTimeout(() =&gt; inputElem.classList.remove('is-valid'), 800);&#10;      }&#10;    } catch (e) {&#10;      alert('パス名の更新に失敗しました');&#10;      try { if (inputElem) inputElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // 画面名変更をサーバへ送信するハンドラ（インライン）&#10;  async function onChangeItemName(item, newName, inputElem) {&#10;    if (!item || item.id == null) return;&#10;    const prev = item.itemName || '';&#10;    // newName は空文字も許容（サーバ側に任せる）。正規化: trim のみ&#10;    const normalized = (newName == null) ? '' : String(newName).trim();&#10;    if (normalized === prev) return;&#10;&#10;    const payload = Object.assign({}, item, { itemName: normalized });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('画面名の更新に失敗しました');&#10;        try {&#10;          if (inputElem) {&#10;            inputElem.value = prev || '';&#10;            inputElem.classList.add('is-invalid');&#10;            setTimeout(() =&gt; inputElem.classList.remove('is-invalid'), 1000);&#10;          }&#10;        } catch (_) {}&#10;        return;&#10;      }&#10;      // update local item and UI&#10;      item.itemName = normalized;&#10;      if (inputElem) {&#10;        if (typeof inputElem.__setPrev === 'function') inputElem.__setPrev(normalized);&#10;        inputElem.classList.add('is-valid');&#10;        setTimeout(() =&gt; inputElem.classList.remove('is-valid'), 800);&#10;      }&#10;    } catch (e) {&#10;      alert('画面名の更新に失敗しました');&#10;      try { if (inputElem) inputElem.value = prev || ''; } catch (_) { }&#10;    }&#10;  }&#10;&#10;  // パスの状態変更（有効/無効）をPUT更新&#10;  async function onChangePathStatus(path, willDisable, selectElem) {&#10;    const prev = !!path.deleted;&#10;    if (prev === willDisable) return;&#10;    const payload = Object.assign({}, path, { deleted: willDisable });&#10;    try {&#10;      const resp = await fetch(apiPaths, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('状態の更新に失敗しました');&#10;        try { selectElem.value = prev ? 'disabled' : 'enabled'; } catch(_){}&#10;        return;&#10;      }&#10;      path.deleted = willDisable;&#10;      // パスの有効/無効に応じて画面管理のプルダウンを更新&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('状態の更新に失敗しました');&#10;      try { selectElem.value = prev ? 'disabled' : 'enabled'; } catch(_){}&#10;    }&#10;  }&#10;&#10;  // --- データロード ---&#10;  // パス一覧（有効のみ）を読み込みテーブルを更新&#10;  async function loadPaths() {&#10;    const tbody = qs('#pathTable tbody');&#10;    // パス管理タブ用テーブルがないページではスキップ&#10;    const isPathsPage = !!tbody;&#10;    if (isPathsPage) tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      // 削除（無効）含む一覧を1回で取得し、キャッシュ・UI双方で利用&#10;      const resp = await fetch(apiPaths + '/allIncludingDeleted');&#10;      if (!resp.ok) {&#10;        if (isPathsPage) tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        pathsCache = [];&#10;        refreshPathSelects();&#10;        return [];&#10;      }&#10;      const all = await resp.json();&#10;      pathsCache = all || [];&#10;      refreshPathSelects();&#10;      tbody.innerHTML = '';&#10;      if (!all || !all.length) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;パスがありません&lt;/td&gt;&lt;/tr&gt;';&#10;        return pathsCache;&#10;      }&#10;      {&#10;        const frag = document.createDocumentFragment();&#10;        all.forEach(p =&gt; frag.appendChild(renderPathRow(p)));&#10;        tbody.appendChild(frag);&#10;      }&#10;      return pathsCache;&#10;    } catch (e) {&#10;      if (isPathsPage) tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      pathsCache = [];&#10;      refreshPathSelects();&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // メニュー一覧を読み込みテーブルを更新&#10;  async function loadMenus() {&#10;    const tbody = qs('#menuTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      const resp = await fetch(apiMenus + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const menus = await resp.json();&#10;      menusCache = menus || [];&#10;      tbody.innerHTML = '';&#10;      if (!menusCache || !menusCache.length) {&#10;        // If there are no menus defined in menu management, try to show menuNames derived from screens&#10;        // This avoids confusing mismatch where home shows menus (from screens) but admin shows none.&#10;        // Load screens and extract unique menuName values.&#10;        try {&#10;          const r = await fetch(apiContent + '/all');&#10;          if (!r.ok) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          const items = await r.json();&#10;          const menuNames = Array.from(new Set((items || []).map(it =&gt; it.menuName).filter(Boolean)));&#10;          if (!menuNames.length) {&#10;            tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;            // still refresh selects to show empty options&#10;            refreshMenuSelects();&#10;            return [];&#10;          }&#10;          const frag = document.createDocumentFragment();&#10;          menuNames.forEach((name) =&gt; {&#10;            const tr = document.createElement('tr');&#10;            const idTd = document.createElement('td'); idTd.textContent = '';&#10;            const nameTd = document.createElement('td'); nameTd.textContent = name + ' (画面管理由来)';&#10;            const actionsTd = document.createElement('td');&#10;&#10;            const importBtn = document.createElement('button');&#10;            importBtn.className = 'btn btn-sm btn-outline-success me-2';&#10;            importBtn.textContent = 'インポート';&#10;            importBtn.addEventListener('click', async () =&gt; {&#10;              // create menu via API&#10;              try {&#10;                const resp2 = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });&#10;                if (!resp2.ok) {&#10;                  alert('インポートに失敗しました');&#10;                  return;&#10;                }&#10;                // reload official menus&#10;                await loadMenus();&#10;                await loadScreens();&#10;              } catch (e) {&#10;                alert('インポートに失敗しました');&#10;              }&#10;            });&#10;&#10;            actionsTd.appendChild(importBtn);&#10;            tr.appendChild(idTd);&#10;            tr.appendChild(nameTd);&#10;            tr.appendChild(actionsTd);&#10;            frag.appendChild(tr);&#10;          });&#10;          tbody.appendChild(frag);&#10;           // ensure selects are refreshed&#10;           refreshMenuSelects();&#10;           return menuNames;&#10;        } catch (e) {&#10;          tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;メニューがありません&lt;/td&gt;&lt;/tr&gt;';&#10;          // still refresh selects to show empty options&#10;          refreshMenuSelects();&#10;          return [];&#10;        }&#10;      }&#10;      {&#10;        const frag = document.createDocumentFragment();&#10;        menusCache.forEach(m =&gt; frag.appendChild(renderMenuRow(m)));&#10;        tbody.appendChild(frag);&#10;      }&#10;       // update any existing select elements in screens&#10;       refreshMenuSelects();&#10;       return menusCache;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // 画面項目一覧を読み込みテーブルを更新&#10;  async function loadScreens() {&#10;    const tbody = qs('#manageTable tbody');&#10;    if (!tbody) return [];&#10;    tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;読み込み中...&lt;/td&gt;&lt;/tr&gt;';&#10;    try {&#10;      // ensure menusCache is populated so selects can be built properly&#10;      if (!menusCache || !menusCache.length) {&#10;        await loadMenus();&#10;      }&#10;      // ensure pathsCache is populated so path selects can be built properly&#10;      if (!pathsCache || !pathsCache.length) {&#10;        await loadPaths();&#10;      }&#10;      const resp = await fetch(apiContent + '/all');&#10;      if (!resp.ok) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      const items = await resp.json();&#10;      tbody.innerHTML = '';&#10;      if (!items || !items.length) {&#10;        tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;項目がありません&lt;/td&gt;&lt;/tr&gt;';&#10;        return [];&#10;      }&#10;      {&#10;        const frag = document.createDocumentFragment();&#10;        items.forEach(it =&gt; frag.appendChild(renderScreenRow(it)));&#10;        tbody.appendChild(frag);&#10;      }&#10;       return items;&#10;    } catch (e) {&#10;      tbody.innerHTML = '&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;読み込みに失敗しました&lt;/td&gt;&lt;/tr&gt;';&#10;      return [];&#10;    }&#10;  }&#10;&#10;  // --- メニュー操作 ---&#10;  // 追加・編集・削除の各操作（ユーザー確認/プロンプトを含む）&#10;  async function onAddMenu() {&#10;    const name = window.prompt('追加するメニュー名を入力してください', '新しいメニュー');&#10;    if (!name) return;&#10;    const payload = { name };&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('メニュー作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      // refresh menu dropdowns for adding screens&#10;      await loadScreens();&#10;      // notify other tabs/pages to refresh sidebar menus&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('メニュー作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditMenu(menu) {&#10;    const name = window.prompt('メニュー名を編集してください', menu.name || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, menu, { name });&#10;    try {&#10;      const resp = await fetch(apiMenus, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteMenu(menu) {&#10;    if (!window.confirm('このメニューを削除してよいですか?（メニューに紐づく画面がある場合、連鎖的な整合性は考慮していません）')) return;&#10;    try {&#10;      const resp = await fetch(apiMenus + '/' + menu.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadMenus();&#10;      await loadScreens();&#10;      try { localStorage.setItem('menus-updated', String(Date.now())); } catch (_) { }&#10;      try { if (menusBroadcast) menusBroadcast.postMessage('menus-updated'); } catch (_) { }&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // --- パス操作 ---&#10;  async function onAddPath() {&#10;    const name = window.prompt('追加するパス名を入力してください（例: passwordGeneration）', '');&#10;    if (!name) return;&#10;    const payload = { name };&#10;    try {&#10;      const resp = await fetch(apiPaths, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) { alert('パス作成に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('パス作成に失敗しました'); }&#10;  }&#10;&#10;  async function onEditPath(path) {&#10;    const name = window.prompt('パス名を編集してください', path.name || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, path, { name });&#10;    try {&#10;      const resp = await fetch(apiPaths, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) { alert('更新に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('更新に失敗しました'); }&#10;  }&#10;&#10;  async function onDeletePath(path) {&#10;    if (!window.confirm('このパスを論理削除します。よろしいですか？')) return;&#10;    try {&#10;      const resp = await fetch(apiPaths + '/' + path.id, { method: 'DELETE' });&#10;      if (!resp.ok) { alert('削除に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('削除に失敗しました'); }&#10;  }&#10;&#10;  async function onRestorePath(path) {&#10;    try {&#10;      const resp = await fetch(apiPaths + '/' + path.id + '/restore', { method: 'POST' });&#10;      if (!resp.ok) { alert('復元に失敗しました'); return; }&#10;      await loadPaths();&#10;      await loadScreens();&#10;    } catch (_) { alert('復元に失敗しました'); }&#10;  }&#10;&#10;  // --- 画面項目操作 ---&#10;  async function onAddScreen() {&#10;    const name = window.prompt('追加する画面名を入力してください', '新しい画面');&#10;    if (!name) return;&#10;    // choose menu from existing&#10;    const menus = await loadMenus();&#10;    if (!menus || !menus.length) {&#10;      alert('先にメニューを追加してください');&#10;      return;&#10;    }&#10;    // build selection prompt&#10;    let list = 'メニューを選んで番号を入力してください:\n';&#10;    menus.forEach((m, idx) =&gt; { list += `${idx + 1}: ${m.name}\n`; });&#10;    const sel = window.prompt(list, '1');&#10;    if (!sel) return;&#10;    const idx = parseInt(sel) - 1;&#10;    if (isNaN(idx) || idx &lt; 0 || idx &gt;= menus.length) { alert('不正な選択'); return; }&#10;    const menuName = menus[idx].name;&#10;    // optional pathName input&#10;    const pathName = window.prompt('この画面のパス名を入力してください（例: passwordGeneration）。空欄でも可', '');&#10;    const payload = { itemName: name, menuName, pathName: (pathName ? pathName.trim() : null) };&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('作成に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('作成に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onEditScreen(item) {&#10;    // Per requirement, menuName is editable via select — here only itemName editable&#10;    const name = window.prompt('画面名を編集してください', item.itemName || '');&#10;    if (name == null) return;&#10;    const payload = Object.assign({}, item, { itemName: name });&#10;    try {&#10;      const resp = await fetch(apiContent, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });&#10;      if (!resp.ok) {&#10;        alert('更新に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('更新に失敗しました');&#10;    }&#10;  }&#10;&#10;  async function onDeleteScreen(item) {&#10;    if (!window.confirm('削除してよいですか?')) return;&#10;    try {&#10;      const resp = await fetch(apiContent + '/' + item.id, { method: 'DELETE' });&#10;      if (!resp.ok) {&#10;        alert('削除に失敗しました');&#10;        return;&#10;      }&#10;      await loadScreens();&#10;    } catch (e) {&#10;      alert('削除に失敗しました');&#10;    }&#10;  }&#10;&#10;  // 初期化: イベントリスナ登録とデータロード&#10;  function initManagePage() {&#10;    try {&#10;      const addMenuBtn = qs('#addMenuBtn');&#10;      if (addMenuBtn &amp;&amp; !addMenuBtn.__bound) {&#10;        addMenuBtn.addEventListener('click', onAddMenu);&#10;        addMenuBtn.__bound = true;&#10;      }&#10;      const addScreenBtn = qs('#addScreenBtn');&#10;      if (addScreenBtn &amp;&amp; !addScreenBtn.__bound) {&#10;        addScreenBtn.addEventListener('click', onAddScreen);&#10;        addScreenBtn.__bound = true;&#10;      }&#10;      const addPathBtn = qs('#addPathBtn');&#10;      if (addPathBtn &amp;&amp; !addPathBtn.__bound) {&#10;        addPathBtn.addEventListener('click', onAddPath);&#10;        addPathBtn.__bound = true;&#10;      }&#10;      // 初回ロード順序&#10;      loadMenus().then(() =&gt; loadPaths()).then(() =&gt; loadScreens());&#10;    } catch (_) { /* ignore */ }&#10;  }&#10;&#10;  // DOMContentLoaded で初期化&#10;  document.addEventListener('DOMContentLoaded', initManagePage);&#10;  // 既に読み込み済みなら即時初期化（フォールバック）&#10;  if (document.readyState === 'interactive' || document.readyState === 'complete') {&#10;    // 少し遅延してDOM構築完了を待つ&#10;    setTimeout(initManagePage, 0);&#10;  }&#10;&#10;  // expose for debugging/static-analysis to avoid 'unused function' warnings&#10;  try { if (typeof window !== 'undefined') { window.__manage_onDeletePath = onDeletePath; window.__manage_onRestorePath = onRestorePath; } } catch(_) {}&#10;&#10;})();&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>